{"version":3,"sources":["/Users/kelei/opensource/selene-pokemoon/selene-core/src/system/entity.mbt","/Users/kelei/opensource/selene-pokemoon/pokemoon/src/__generated_driver_for_blackbox_test.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/system/keycode.mbt","/Users/kelei/opensource/selene-pokemoon/selene-canvas/src/canvas.mbt","/Users/kelei/opensource/selene-pokemoon/selene-canvas/src/draw.mbt","/Users/kelei/opensource/selene-pokemoon/selene-canvas/src/audio.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/position/position.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/camera/top.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/shape.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/pickable.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/quadtree.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/collider.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/layer.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/move.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/system/defer.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/collision/area.mbt","/Users/kelei/opensource/selene-pokemoon/selene-core/src/system/timer.mbt","/Users/kelei/opensource/selene-pokemoon/pokemoon/src/battle_system.mbt","/Users/kelei/.moon/lib/core/abort/abort.mbt","/Users/kelei/.moon/lib/core/ref/ref.mbt","/Users/kelei/.moon/lib/core/set/grow_heuristic.mbt","/Users/kelei/.moon/lib/core/set/linked_hash_set.mbt","/Users/kelei/.moon/lib/core/builtin/traits.mbt","/Users/kelei/.moon/lib/core/builtin/stringbuilder_concat.mbt","/Users/kelei/.moon/lib/core/builtin/show.mbt","/Users/kelei/.moon/lib/core/builtin/array.mbt","/Users/kelei/.moon/lib/core/builtin/hasher.mbt","/Users/kelei/.moon/lib/core/builtin/deprecated.mbt","/Users/kelei/.moon/lib/core/builtin/output.mbt","/Users/kelei/.moon/lib/core/builtin/to_string.mbt","/Users/kelei/.moon/lib/core/builtin/string.mbt","/Users/kelei/.moon/lib/core/builtin/option.mbt","/Users/kelei/.moon/lib/core/builtin/linked_hash_map.mbt","/Users/kelei/.moon/lib/core/builtin/int.mbt","/Users/kelei/.moon/lib/core/builtin/console.mbt","/Users/kelei/.moon/lib/core/builtin/arraycore_js.mbt"],"sourcesContent":["// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Unique identifier for game objects in the entity-component system.\n///\n/// Example:\n///\n/// ```notest\n/// let entity = @system.Entity::new()\n/// if entity.is_alive() {\n///   println(\"Entity is active\")\n/// }\n/// entity.destroy()\n/// ```\n///\nstruct Entity(UInt) derive(Eq, Show, Hash)\n\n///|\nlet all_entities : @set.Set[Entity] = @set.Set::new()\n\n///|\npub fn iter_entities() -> Iter[Entity] {\n  all_entities.iter()\n}\n\n///|\n/// Checks whether an entity is currently active in the entity-component system.\n///\n/// Parameters:\n///\n/// * `entity` : The entity to check for activity status.\n///\n/// Returns `true` if the entity is currently active and tracked in the system,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```notest\n/// let entity = @system.Entity::new()\n/// inspect(entity.is_alive(), content=\"true\")\n///\n/// entity.destroy()\n/// // Note: The entity will be marked as inactive during the next deferred event cycle\n/// ```\n///\npub fn Entity::is_alive(e : Entity) -> Bool {\n  all_entities.contains(e)\n}\n\n///|\nlet entity_generator : Ref[UInt] = { val: 0 }\n\n///|\npub fn Entity::new() -> Entity {\n  let entity = entity_generator.val\n  entity_generator.val += 1\n  all_entities.add(entity)\n  entity\n}\n\n///|\n/// Marks an entity for destruction, scheduling its removal from the\n/// entity-component system during the next deferred event processing cycle.\n///\n/// Parameters:\n///\n/// * `entity` : The entity to be destroyed.\n///\n/// Example:\n///\n/// ```notest\n/// let entity = @system.Entity::new()\n/// inspect(entity.is_alive(), content=\"true\")\n///\n/// entity.destroy()\n/// // Entity will be removed from all_entities during next deferred event cycle\n/// ```\n///\npub fn Entity::destroy(e : Entity) -> Unit {\n  defer_event(fn() { all_entities.remove(e) })\n}\n\n///|\n/// Reactivates a previously destroyed entity by adding it back to the active\n/// entities collection.\n///\n/// Parameters:\n///\n/// * `entity` : The entity to be reactivated in the entity-component system.\n///\n/// Example:\n///\n/// ```notest\n/// let entity = @system.Entity::new()\n/// inspect(entity.is_alive(), content=\"true\")\n///\n/// entity.destroy()\n/// inspect(entity.is_alive(), content=\"false\")\n/// // Entity is marked for removal during next deferred event cycle\n///\n/// entity.respawn()\n/// inspect(entity.is_alive(), content=\"true\") // Entity is active again\n/// ```\n///\npub fn Entity::respawn(e : Entity) -> Unit {\n  all_entities.add(e)\n}\n",null,"// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Keyboard key code representing a specific key on the keyboard.\n///\n/// Example:\n///\n/// ```notest\n/// let key_code = @system.Code::from_string(\"KeyA\")\n/// match key_code {\n///   Some(KeyA) => println(\"A key pressed\")\n///   Some(Space) => println(\"Space key pressed\")\n///   Some(ArrowUp) => println(\"Up arrow pressed\")\n///   None => println(\"Unknown key\")\n/// }\n///\n/// // Check if a key is currently pressed\n/// if @system.is_pressed(KeyW) {\n///   println(\"W key is being held down\")\n/// }\n///\n/// // Check if a key was just pressed this frame\n/// if @system.is_just_pressed(Space) {\n///   println(\"Space was just pressed\")\n/// }\n/// ```\n///\npub(all) enum Code {\n  KeyA\n  KeyB\n  KeyC\n  KeyD\n  KeyE\n  KeyF\n  KeyG\n  KeyH\n  KeyI\n  KeyJ\n  KeyK\n  KeyL\n  KeyM\n  KeyN\n  KeyO\n  KeyP\n  KeyQ\n  KeyR\n  KeyS\n  KeyT\n  KeyU\n  KeyV\n  KeyW\n  KeyX\n  KeyY\n  KeyZ\n  ArrowUp\n  ArrowDown\n  ArrowLeft\n  ArrowRight\n  Space\n  Enter\n  Escape\n} derive(Eq, Show, Hash)\n\n///|\nlet all_codes : @set.Set[Code] = @set.Set::from_array([\n  KeyA,\n  KeyB,\n  KeyC,\n  KeyD,\n  KeyE,\n  KeyF,\n  KeyG,\n  KeyH,\n  KeyI,\n  KeyJ,\n  KeyK,\n  KeyL,\n  KeyM,\n  KeyN,\n  KeyO,\n  KeyP,\n  KeyQ,\n  KeyR,\n  KeyS,\n  KeyT,\n  KeyU,\n  KeyV,\n  KeyW,\n  KeyX,\n  KeyY,\n  KeyZ,\n  ArrowUp,\n  ArrowDown,\n  ArrowLeft,\n  ArrowRight,\n  Space,\n  Enter,\n  Escape,\n])\n\n///|\n/// Converts a string representation of a keyboard key into its corresponding\n/// `Code` enum variant.\n///\n/// Parameters:\n///\n/// * `code` : The string representation of the keyboard key (e.g., \"KeyA\",\n///   \"Space\", \"ArrowUp\").\n///\n/// Returns `Some(Code)` if the string matches a valid key code, or `None` if\n/// the string is not recognized.\n///\n/// Example:\n///\n/// ```notest\n/// let key_a = @system.Code::from_string(\"KeyA\")\n/// inspect(key_a, content=\"Some(KeyA)\")\n///\n/// let space_key = @system.Code::from_string(\"Space\")\n/// inspect(space_key, content=\"Some(Space)\")\n///\n/// let invalid_key = @system.Code::from_string(\"InvalidKey\")\n/// inspect(invalid_key, content=\"None\")\n/// ```\n///\npub fn Code::from_string(code : String) -> Code? {\n  match code {\n    \"KeyA\" => Some(KeyA)\n    \"KeyB\" => Some(KeyB)\n    \"KeyC\" => Some(KeyC)\n    \"KeyD\" => Some(KeyD)\n    \"KeyE\" => Some(KeyE)\n    \"KeyF\" => Some(KeyF)\n    \"KeyG\" => Some(KeyG)\n    \"KeyH\" => Some(KeyH)\n    \"KeyI\" => Some(KeyI)\n    \"KeyJ\" => Some(KeyJ)\n    \"KeyK\" => Some(KeyK)\n    \"KeyL\" => Some(KeyL)\n    \"KeyM\" => Some(KeyM)\n    \"KeyN\" => Some(KeyN)\n    \"KeyO\" => Some(KeyO)\n    \"KeyP\" => Some(KeyP)\n    \"KeyQ\" => Some(KeyQ)\n    \"KeyR\" => Some(KeyR)\n    \"KeyS\" => Some(KeyS)\n    \"KeyT\" => Some(KeyT)\n    \"KeyU\" => Some(KeyU)\n    \"KeyV\" => Some(KeyV)\n    \"KeyW\" => Some(KeyW)\n    \"KeyX\" => Some(KeyX)\n    \"KeyY\" => Some(KeyY)\n    \"KeyZ\" => Some(KeyZ)\n    \"ArrowUp\" => Some(ArrowUp)\n    \"ArrowDown\" => Some(ArrowDown)\n    \"ArrowLeft\" => Some(ArrowLeft)\n    \"ArrowRight\" => Some(ArrowRight)\n    \"Space\" => Some(Space)\n    \"Enter\" => Some(Enter)\n    \"Escape\" => Some(Escape)\n    _ => None\n  }\n}\n\n///|\npub let pressed_keys : Set[Code] = @set.Set::new()\n\n///|\npub fn is_pressed(code : Code) -> Bool {\n  pressed_keys.contains(code)\n}\n\n///|\npub fn is_released(code : Code) -> Bool {\n  !pressed_keys.contains(code)\n}\n\n///|\n/// Creates a directional vector based on the current state of four directional\n/// keys.\n///\n/// Parameters:\n///\n/// * `up` : The keyboard key code for upward movement.\n/// * `down` : The keyboard key code for downward movement.\n/// * `left` : The keyboard key code for leftward movement.\n/// * `right` : The keyboard key code for rightward movement.\n///\n/// Returns a 2D vector representing the combined directional input, where\n/// x-component ranges from -1.0 (left) to 1.0 (right) and y-component ranges\n/// from -1.0 (up) to 1.0 (down).\n///\n/// Example:\n///\n/// ```notest\n/// // Get movement vector for WASD keys\n/// let movement = @system.key_vector(@system.KeyW, @system.KeyS, @system.KeyA, @system.KeyD)\n/// println(\"Movement: \\{movement}\")\n///\n/// // Get movement vector for arrow keys\n/// let arrow_movement = @system.key_vector(@system.ArrowUp, @system.ArrowDown, @system.ArrowLeft, @system.ArrowRight)\n/// println(\"Arrow movement: \\{arrow_movement}\")\n/// ```\n///\npub fn key_vector(\n  up : Code,\n  down : Code,\n  left : Code,\n  right : Code,\n) -> @math.Vec2D {\n  let x = if is_pressed(left) {\n    -1.0\n  } else if is_pressed(right) {\n    1.0\n  } else {\n    0.0\n  }\n  let y = if is_pressed(up) {\n    -1.0\n  } else if is_pressed(down) {\n    1.0\n  } else {\n    0.0\n  }\n  @math.Vec2D(x, y)\n}\n\n///|\nlet last_pressed_keys : Set[Code] = @set.Set::new()\n\n///|\nlet just_pressed_keys : Set[Code] = @set.Set::new()\n\n///|\nlet just_release_keys : Set[Code] = @set.Set::new()\n\n///|\n/// Updates the internal state for tracking key press transitions between\n/// frames.\n///\n/// Parameters:\n///\n/// * `backend` : The backend interface for handling platform-specific\n///   operations (currently unused).\n///\n/// Example:\n///\n/// ```notest\n/// // This system function is typically called automatically by the game framework\n/// // during each frame update to maintain accurate key state tracking\n/// @system.advanced_key_system(backend)\n///\n/// // After calling this system, you can use the transition detection functions:\n/// if @system.is_just_pressed(@system.KeyA) {\n///   // Handle key A being pressed this frame\n/// }\n/// if @system.is_just_released(@system.KeyB) {\n///   // Handle key B being released this frame  \n/// }\n/// ```\n///\npub fn advanced_key_system(_backend : &Backend) -> Unit {\n  just_pressed_keys.clear()\n  for code in pressed_keys.difference(last_pressed_keys) {\n    just_pressed_keys.add(code)\n  }\n  just_release_keys.clear()\n  for code in all_codes.difference(pressed_keys).union(last_pressed_keys) {\n    just_release_keys.add(code)\n  }\n  last_pressed_keys.clear()\n  for code in pressed_keys {\n    last_pressed_keys.add(code)\n  }\n}\n\n///|\n/// Checks if a keyboard key was just pressed during the current frame.\n///\n/// Parameters:\n///\n/// * `code` : The keyboard key code to check for recent press activity.\n///\n/// Returns `true` if the specified key was pressed this frame (transition from\n/// released to pressed state), `false` otherwise.\n///\n/// Example:\n///\n/// ```notest\n/// // Check if the space key was just pressed this frame\n/// if @system.is_just_pressed(@system.Space) {\n///   println(\"Space key was just pressed!\")\n/// }\n///\n/// // Check for WASD movement keys\n/// if @system.is_just_pressed(@system.KeyW) {\n///   println(\"Moving forward\")\n/// }\n/// if @system.is_just_pressed(@system.KeyA) {\n///   println(\"Moving left\")\n/// }\n/// ```\n///\npub fn is_just_pressed(code : Code) -> Bool {\n  just_pressed_keys.contains(code)\n}\n\n///|\n/// Checks if a keyboard key was just released during the current frame.\n///\n/// Parameters:\n///\n/// * `code` : The keyboard key code to check for recent release activity.\n///\n/// Returns `true` if the specified key was released this frame (transition from\n/// pressed to released state), `false` otherwise.\n///\n/// Example:\n///\n/// ```notest\n/// // Check if the space key was just released this frame\n/// if @system.is_just_released(@system.Space) {\n///   println(\"Space key was just released!\")\n/// }\n///\n/// // Check for WASD movement keys\n/// if @system.is_just_released(@system.KeyW) {\n///   println(\"Stopped moving forward\")\n/// }\n/// if @system.is_just_released(@system.KeyA) {\n///   println(\"Stopped moving left\")\n/// }\n/// ```\n///\npub fn is_just_released(code : Code) -> Bool {\n  just_pressed_keys.contains(code)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct CanvasBackend {\n  canvas : @dom.HTMLCanvasElement\n  context : @dom.CanvasRenderingContext2D\n  mut viewport_size : @math.Vec2D\n  mut frame_counter : UInt64\n  mut current_fps : Double\n  mut zoom : Double\n  execution_time : Map[String, Double]\n  mouse_movement : Ref[@system.MouseMovement?]\n}\n\n///|\npub fn CanvasBackend::new() -> CanvasBackend {\n  let canvas = @dom.document()\n    .get_element_by_id(\"canvas\")\n    .unwrap()\n    .to_html_canvas_element()\n    .unwrap()\n  let context = canvas.get_context(\"2d\").to0().unwrap()\n  {\n    context,\n    canvas,\n    viewport_size: @math.Vec2D::zero(),\n    current_fps: 0.0,\n    frame_counter: 0,\n    execution_time: {},\n    mouse_movement: Ref::new(None),\n    zoom: 1.0,\n  }\n}\n\n///|\npub impl @system.Backend for CanvasBackend with build(\n  self,\n  systems,\n  canvas_width,\n  canvas_height,\n  fps,\n  image_smooth,\n  zoom,\n) {\n  if fps > 60 {\n    println(\n      \"Warning: FPS is set above 60. The browser's window only support up to 60 FPS.\",\n    )\n  }\n  for system in systems {\n    if system.1 is Startup {\n      (system.0)(self)\n    }\n  }\n  self.viewport_size = @math.Vec2D(canvas_width, canvas_height)\n  set_viewport_height(self.canvas, canvas_height)\n  set_viewport_width(self.canvas, canvas_width)\n  set_image_smoothing_enabled(self.context, image_smooth)\n  self.context.scale(zoom, zoom)\n  self.zoom = zoom\n  schedule_with_fixed_interval(1000 / fps.to_double(), fn(delta) {\n    self.current_fps = 1000.0 / delta\n    self.context.clear_rect(0, 0, canvas_width, canvas_height)\n    let renders = []\n    for system in systems {\n      let start_time = time_now()\n      match system.1 {\n        UpdateFrame(frame_period) if self.frame_counter %\n          frame_period.to_uint64() ==\n          0 => {\n          (system.0)(self)\n          self.execution_time[system.2] = time_now() - start_time\n        }\n        Render(priority) => renders.push((system.0, priority))\n        Update => {\n          (system.0)(self)\n          self.execution_time[system.2] = time_now() - start_time\n        }\n        UpdateTime(period) if self.frame_counter %\n          (fps.to_double() * period).to_uint64() ==\n          0 => {\n          (system.0)(self)\n          self.execution_time[system.2] = time_now() - start_time\n        }\n        _ => ()\n      }\n    }\n    renders.sort_by_key(fn(system) { -system.1 })\n    for render in renders {\n      (render.0)(self)\n    }\n    if self.mouse_movement.val is Some(mouse_movement) {\n      mouse_movement.movement = @math.Vec2D(0.0, 0.0)\n    }\n    self.frame_counter += 1\n  })\n  |> ignore\n  return fn() {  }\n}\n\n///|\npub impl @system.Backend for CanvasBackend with get_canvas_size(self) {\n  @math.Vec2D(self.viewport_size[X], self.viewport_size[Y])\n}\n\n///|\npub impl @system.Backend for CanvasBackend with get_debug_info(self) {\n  { system_execution_time: self.execution_time, fps: self.current_fps }\n}\n\n///|\npub impl @system.Backend for CanvasBackend with get_zoom(self) {\n  self.zoom\n}\n\n///|\nlet window : @dom.Window = @dom.window()\n\n///|\nfn schedule_with_fixed_interval(\n  interval : Double,\n  callback : (Double) -> Unit,\n) -> () -> Unit {\n  let lastTime = { val: 0.0 }\n  let accumulator = { val: 0.0 }\n  let lastId = { val: 0.0 }\n  fn update(time : Double) -> Unit {\n    if lastTime.val == 0.0 {\n      lastTime.val = time\n    }\n    let delta = time - lastTime.val\n    lastTime.val = time\n    accumulator.val = accumulator.val + delta\n\n    // Run callback for each complete interval\n    while accumulator.val >= interval {\n      callback(delta)\n      accumulator.val = accumulator.val - interval\n    }\n    lastId.val = window.request_animation_frame(update)\n  }\n\n  lastId.val = window.request_animation_frame(update)\n  () => if lastId.val != 0.0 { window.cancel_animation_frame(lastId.val) }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nlet element_cache : Map[String, @dom.HTMLImageElement] = Map::new()\n\n///|\nfn get_image_element(png : String) -> @dom.HTMLImageElement {\n  if element_cache.get(png) is Some(element) {\n    return element\n  }\n  let element = @dom.HTMLImageElement::new()\n  element.set_src(png)\n  element_cache.set(png, element)\n  return element\n}\n\n///|\npub impl @system.Backend for CanvasBackend with preload_img(\n  _self,\n  path : String,\n) -> Unit {\n  get_image_element(path) |> ignore\n}\n\n///|\npub impl @system.Backend for CanvasBackend with draw_picture(\n  self,\n  png,\n  x~,\n  y~,\n  width~,\n  height~,\n  transform~,\n  repeat~,\n) {\n  let element = get_image_element(png)\n  let repeat_mode = match repeat {\n    NoRepeat => \"no-repeat\"\n    RepeatY => \"repeat-y\"\n    RepeatX => \"repeat-x\"\n    Repeat => \"repeat\"\n  }\n  let pattern = self.context.create_pattern(\n    @js.Union7::from0(element),\n    repeat_mode,\n  )\n  self.context.save()\n  self.context.set_fill_style(@js.Union3::from2(pattern))\n  self.context.translate(x, y)\n  self.context.transform(\n    transform.a,\n    transform.b,\n    transform.c,\n    transform.d,\n    transform.tx,\n    transform.ty,\n  )\n  self.context.fill_rect(0, 0, width, height)\n  self.context.restore()\n}\n\n///|\npub impl @system.Backend for CanvasBackend with draw_sprite(\n  self,\n  sprite_path,\n  x~,\n  y~,\n  offset_x~,\n  offset_y~,\n  width~,\n  height~,\n  transform~,\n) {\n  self.context.save()\n  self.context.translate(x, y)\n  self.context.transform(\n    transform.a,\n    transform.b,\n    transform.c,\n    transform.d,\n    transform.tx,\n    transform.ty,\n  )\n  let element = get_image_element(sprite_path)\n  self.context.draw_image_with_src_and_dst_size(\n    element |> @js.Value::cast_from |> @js.Value::cast,\n    offset_x,\n    offset_y,\n    width,\n    height,\n    0,\n    0,\n    width,\n    height,\n  )\n  self.context.restore()\n}\n\n///|\npub impl @system.Backend for CanvasBackend with draw_stroke_rect(\n  self,\n  x~,\n  y~,\n  width~,\n  height~,\n  color~,\n) {\n  self.context.save()\n  self.context.set_stroke_style(@js.Union3::from0(color))\n  self.context.stroke_rect(x, y, width, height)\n  self.context.restore()\n}\n\n///|\npub impl @system.Backend for CanvasBackend with draw_text(\n  self,\n  text,\n  x~,\n  y~,\n  font~,\n  color~,\n) {\n  self.context.save()\n  self.context.set_font(font)\n  self.context.set_fill_style(@js.Union3::from0(color))\n  self.context.fill_text(text, x, y)\n  self.context.restore()\n}\n\n///|\npub impl @system.Backend for CanvasBackend with draw_color_rect(\n  self,\n  x~,\n  y~,\n  width~,\n  height~,\n  color~,\n) {\n  self.context.save()\n  self.context.set_fill_style(@js.Union3::from0(color))\n  self.context.fill_rect(x, y, width, height)\n  self.context.restore()\n}\n\n///|\npub impl @system.Backend for CanvasBackend with draw_gradient_rect(\n  self,\n  x~,\n  y~,\n  width~,\n  height~,\n  color_start~,\n  color_end~,\n) {\n  self.context.save()\n  let gradient = self.context.create_linear_gradient(\n    x,\n    y,\n    x + width,\n    y + height,\n  )\n  gradient.add_color_stop(0.0, color_start)\n  gradient.add_color_stop(1.0, color_end)\n  self.context.set_fill_style(@js.Union3::from1(gradient))\n  self.context.fill_rect(x, y, width, height)\n  self.context.restore()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#external\ntype Audio\n\n///|\npub extern \"js\" fn Audio::new(path : String) -> Audio = \"(path) => new Audio(path)\"\n\n///|\npub extern \"js\" fn Audio::play(self : Self) -> Unit = \"(self) => self.play()\"\n\n///|\npub extern \"js\" fn Audio::pause(self : Self) -> Unit = \"(self) => self.pause()\"\n\n///|\npub extern \"js\" fn Audio::set_volume(self : Self, volume : Double) -> Unit = \"(self, volume) => self.volume = volume\"\n\n///|\npub extern \"js\" fn Audio::set_loop(self : Self, loop_ : Bool) -> Unit = \"(self, loop_) => self.loop = loop_\"\n\n///|\nlet audio_cache : Map[String, Audio] = Map::new()\n\n///|\nfn get_audio(path : String) -> Audio {\n  if audio_cache.get(path) is Some(audio) {\n    return audio\n  }\n  let audio = Audio::new(path)\n  audio_cache.set(path, audio)\n  audio\n}\n\n///|\npub impl @system.Backend for CanvasBackend with play_audio(\n  _self,\n  audio_path : String,\n  volume~ : Double,\n  loop_~ : Bool,\n) -> Unit {\n  let audio = get_audio(audio_path)\n  audio.set_volume(volume)\n  audio.set_loop(loop_)\n  audio.play()\n}\n\n///|\npub impl @system.Backend for CanvasBackend with preload_audio(\n  _self,\n  audio_path : String,\n) -> Unit {\n  get_audio(audio_path) |> ignore\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub(all) struct Position(@math.Vec2D) derive(Eq, Show)\n\n///|\n/// Get the position of an entity.\n/// ```notest\n/// @position.positions.get(entity)\n/// ```\n/// Returns `None` if the entity does not have a position.\n/// \n/// Set the position of an entity.\n/// ```notest\n/// @position.positions.set(entity, Position(@math.Vec2D(100.0, 100.0)))\n/// ```\n/// \npub let positions : Map[@system.Entity, Position] = Map::new()\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npriv struct Camera {\n  mut position : @math.Vec2D\n  mut limit_top : Double?\n  mut limit_bottom : Double?\n  mut limit_left : Double?\n  mut limit_right : Double?\n  mut attached_entity : @system.Entity?\n  mut offset : @math.Vec2D\n  mut follow_x : Bool\n  mut follow_y : Bool\n}\n\n///|\n/// Returns the current position of the global camera.\n///\n/// Returns a `@math.Vec2D` representing the camera's current position\n/// coordinates.\n///\n/// Example:\n///\n/// ```notest\n/// let current_pos = @camera.get_position()\n/// println(\"Camera is at: (\\{current_pos[X]}, \\{current_pos[Y]})\")\n/// ```\n///\npub fn get_position() -> @math.Vec2D {\n  camera.position\n}\n\n///|\n/// Sets the camera's movement boundaries to constrain its position within\n/// specified limits.\n///\n/// Parameters:\n///\n/// * `top` : The topmost Y coordinate the camera can reach. If `None`, no top\n///   limit is applied.\n/// * `bottom` : The bottommost Y coordinate the camera can reach. If `None`, no\n///   bottom limit is applied.\n/// * `left` : The leftmost X coordinate the camera can reach. If `None`, no\n///   left limit is applied.\n/// * `right` : The rightmost X coordinate the camera can reach. If `None`, no\n///   right limit is applied.\n///\n/// Example:\n///\n/// ```notest\n/// // Set boundaries to keep camera within a level area\n/// @camera.set_limits(top=0.0, bottom=500.0, left=0.0, right=800.0)\n///\n/// // Set only horizontal limits, allowing unlimited vertical movement\n/// @camera.set_limits(left=0.0, right=1000.0)\n///\n/// // Remove all limits\n/// @camera.set_limits()\n/// ```\n///\npub fn set_limits(\n  top? : Double,\n  bottom? : Double,\n  left? : Double,\n  right? : Double,\n) -> Unit {\n  camera.limit_top = top\n  camera.limit_bottom = bottom\n  camera.limit_left = left\n  camera.limit_right = right\n}\n\n///|\n/// Attaches an entity to the camera for automatic following with a specified\n/// offset.\n///\n/// Parameters:\n///\n/// * `entity` : The entity that the camera should follow.\n/// * `offset` : The positional offset from the entity's position where the\n///   camera should be positioned.\n///\n/// Example:\n///\n/// ```notest\n/// @camera.attach_entity(player_entity, @math.Vec2D(32.0, 32.0))\n/// @camera.attach_entity(enemy_entity, @math.Vec2D::zero())\n/// ```\n///\npub fn attach_entity(entity : @system.Entity, offset : @math.Vec2D) -> Unit {\n  camera.attached_entity = Some(entity)\n  camera.offset = offset\n}\n\n///|\n/// Configures whether the camera should follow the attached entity along the\n/// X-axis.\n///\n/// Parameters:\n///\n/// * `follow` : Whether to enable X-axis following. When `true`, the camera\n///   will automatically update its X position to follow the attached entity\n///   horizontally. When `false`, the camera's X position remains fixed\n///   regardless of the entity's horizontal movement.\n///\n/// Example:\n///\n/// ```notest\n/// // Enable horizontal following\n/// @camera.set_follow_x(true)\n///\n/// // Disable horizontal following while keeping vertical following\n/// @camera.set_follow_x(false)\n/// @camera.set_follow_y(true)\n/// ```\n///\npub fn set_follow_x(follow : Bool) -> Unit {\n  camera.follow_x = follow\n}\n\n///|\n/// Configures whether the camera should follow the attached entity along the\n/// Y-axis.\n///\n/// Parameters:\n///\n/// * `follow` : Whether to enable Y-axis following. When `true`, the camera\n///   will automatically update its Y position to follow the attached entity\n///   vertically. When `false`, the camera's Y position remains fixed regardless\n///   of the entity's vertical movement.\n///\n/// Example:\n///\n/// ```notest\n/// // Enable vertical following\n/// @camera.set_follow_y(true)\n///\n/// // Disable vertical following while keeping horizontal following\n/// @camera.set_follow_y(false)\n/// @camera.set_follow_x(true)\n/// ```\n///\npub fn set_follow_y(follow : Bool) -> Unit {\n  camera.follow_y = follow\n}\n\n///|\nlet camera : Camera = {\n  position: @math.Vec2D::zero(),\n  limit_bottom: None,\n  limit_left: None,\n  limit_top: None,\n  limit_right: None,\n  attached_entity: None,\n  offset: @math.Vec2D::zero(),\n  follow_x: true,\n  follow_y: true,\n}\n\n///|\n/// Updates the global camera position based on the attached entity and applies\n/// movement constraints.\n///\n/// This system function should be called every frame to automatically update\n/// the camera position. It follows an attached entity (if set) while respecting\n/// the configured axis constraints and boundary limits. The camera position\n/// represents the top-left corner of the viewport.\n///\n/// Parameters:\n///\n/// * `backend` : The system backend that provides canvas size information for\n///   viewport calculations.\n///\n/// Example:\n///\n/// ```notest\n/// // Add the camera system to your game loop\n/// app.add_system(@camera.camera_system)\n///\n/// // Attach an entity for the camera to follow\n/// camera.attached_entity = Some(player_entity)\n///\n/// // Set movement limits\n/// camera.limit_top = Some(0.0)\n/// camera.limit_bottom = Some(500.0)\n/// camera.limit_left = Some(0.0)\n/// camera.limit_right = Some(650.0)\n///\n/// // Configure following behavior\n/// camera.follow_x = true\n/// camera.follow_y = true\n///\n/// // Set offset to center camera on entity\n/// camera.offset = @math.Vec2D(32.0, 32.0)  // Half of entity size\n/// ```\n///\npub fn camera_system(backend : &@system.Backend) -> Unit {\n  guard camera.attached_entity is Some(e) else { return }\n  guard @position.positions.get(e) is Some(pos) else { return }\n  let zoom = backend.get_zoom()\n  let viewport_size = backend.get_canvas_size() * Vec2D(1 / zoom, 1 / zoom)\n  let target_position = pos.0 -\n    viewport_size * @math.Vec2D(0.5, 0.5) +\n    camera.offset\n\n  // Apply axis constraints for following\n  let new_x = if camera.follow_x {\n    target_position[X]\n  } else {\n    camera.position[X]\n  }\n  let new_y = if camera.follow_y {\n    target_position[Y]\n  } else {\n    camera.position[Y]\n  }\n  camera.position = @math.Vec2D(new_x, new_y)\n  if camera.limit_top is Some(top) && camera.position[Y] < top {\n    camera.position = @math.Vec2D(camera.position[X], top)\n  }\n  if camera.limit_bottom is Some(bottom) &&\n    camera.position[Y] > bottom - viewport_size[Y] {\n    camera.position = @math.Vec2D(camera.position[X], bottom - viewport_size[Y])\n  }\n  if camera.limit_left is Some(left) && camera.position[X] < left {\n    camera.position = @math.Vec2D(left, camera.position[Y])\n  }\n  if camera.limit_right is Some(right) &&\n    camera.position[X] > right - viewport_size[X] {\n    camera.position = @math.Vec2D(right - viewport_size[X], camera.position[Y])\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// The `CollisionShape` enum represents different shapes that can be used for collision detection.\n/// It currently supports rectangular shapes defined by their size and offset.\npub(all) enum CollisionShape {\n  Rect(size~ : @math.Vec2D, offset~ : @math.Vec2D)\n}\n\n///|\npub let shapes : Map[@system.Entity, CollisionShape] = Map::new()\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Component for handling mouse interactions on entities.\n///\n/// Pickable stores callback functions that are triggered when mouse events\n/// occur on an entity. It manages four types of mouse event callbacks: pressed\n/// (while held down), released (while not held down), just pressed (at the\n/// moment of pressing), and just released (at the moment of releasing).\n///\n/// Fields:\n///\n/// * `on_pressed_callbacks` : Callbacks executed while a mouse button is held\n///   down on the entity.\n/// * `on_released_callbacks` : Callbacks executed while a mouse button is not\n///   held down on the entity.\n/// * `on_just_pressed_callbacks` : Callbacks executed at the exact moment a\n///   mouse button is pressed on the entity.\n/// * `on_just_released_callbacks` : Callbacks executed at the exact moment a\n///   mouse button is released on the entity.\n///\n/// Example:\n///\n/// ```notest\n/// let pickable = Pickable::new()\n/// pickable.on_just_pressed(fn(button) { \n///   println(\"Button \\{button} was just pressed\") \n/// })\n/// pickable.on_pressed(fn(button) { \n///   println(\"Button \\{button} is being held down\") \n/// })\n/// ```\n///\nstruct Pickable {\n  on_pressed_callbacks : Array[(@system.MouseButton) -> Unit]\n  on_released_callbacks : Array[(@system.MouseButton) -> Unit]\n  on_just_pressed_callbacks : Array[(@system.MouseButton) -> Unit]\n  on_just_released_callbacks : Array[(@system.MouseButton) -> Unit]\n}\n\n///|\npub let pickables : Map[@system.Entity, Pickable] = Map::new()\n\n///|\n/// Creates a new `Pickable` instance with empty callback arrays.\n///\n/// Returns a new `Pickable` with all mouse event callback arrays initialized as\n/// empty arrays.\n///\n/// Example:\n///\n/// ```notest\n/// let pickable = Pickable::new()\n/// pickable.on_pressed(fn(button) { println(\"Mouse button pressed: \\{button}\") })\n/// ```\n///\npub fn Pickable::new() -> Pickable {\n  {\n    on_pressed_callbacks: [],\n    on_released_callbacks: [],\n    on_just_pressed_callbacks: [],\n    on_just_released_callbacks: [],\n  }\n}\n\n///|\n/// Registers a callback function to be executed while a mouse button is held\n/// down on the entity.\n///\n/// Parameters:\n///\n/// * `self` : The `Pickable` component to add the callback to.\n/// * `callback` : The function to execute while a mouse button is pressed,\n///   receiving the pressed mouse button as a parameter.\n///\n/// Example:\n///\n/// ```notest\n/// let pickable = Pickable::new()\n/// pickable.on_pressed(fn(button) { \n///   println(\"Mouse button \\{button} is being held down\") \n/// })\n/// ```\n///\npub fn Pickable::on_pressed(\n  self : Pickable,\n  callback : (@system.MouseButton) -> Unit,\n) -> Unit {\n  self.on_pressed_callbacks.push(callback)\n}\n\n///|\n/// Registers a callback function to be executed while a mouse button is not\n/// held down on the entity.\n///\n/// Parameters:\n///\n/// * `self` : The `Pickable` component to add the callback to.\n/// * `callback` : The function to execute while a mouse button is released,\n///   receiving the released mouse button as a parameter.\n///\n/// Example:\n///\n/// ```notest\n/// let pickable = Pickable::new()\n/// pickable.on_released(fn(button) { \n///   println(\"Mouse button \\{button} is not being held down\") \n/// })\n/// ```\n///\npub fn Pickable::on_released(\n  self : Pickable,\n  callback : (@system.MouseButton) -> Unit,\n) -> Unit {\n  self.on_released_callbacks.push(callback)\n}\n\n///|\n/// Registers a callback function to be executed at the exact moment a mouse\n/// button is pressed on the entity.\n///\n/// Parameters:\n///\n/// * `self` : The `Pickable` component to add the callback to.\n/// * `callback` : The function to execute when a mouse button is just pressed,\n///   receiving the pressed mouse button as a parameter.\n///\n/// Example:\n///\n/// ```notest\n/// let pickable = Pickable::new()\n/// pickable.on_just_pressed(fn(button) { \n///   println(\"Mouse button \\{button} was just pressed\") \n/// })\n/// ```\n///\npub fn Pickable::on_just_pressed(\n  self : Pickable,\n  callback : (@system.MouseButton) -> Unit,\n) -> Unit {\n  self.on_just_pressed_callbacks.push(callback)\n}\n\n///|\n/// Registers a callback function to be executed at the exact moment a mouse\n/// button is released on the entity.\n///\n/// Parameters:\n///\n/// * `self` : The `Pickable` component to add the callback to.\n/// * `callback` : The function to execute when a mouse button is just released,\n///   receiving the released mouse button as a parameter.\n///\n/// Example:\n///\n/// ```notest\n/// let pickable = Pickable::new()\n/// pickable.on_just_released(fn(button) { \n///   println(\"Mouse button \\{button} was just released\") \n/// })\n/// ```\n///\npub fn Pickable::on_just_released(\n  self : Pickable,\n  callback : (@system.MouseButton) -> Unit,\n) -> Unit {\n  self.on_just_released_callbacks.push(callback)\n}\n\n///|\n/// Processes mouse interactions with pickable entities in both UI and world\n/// space.\n///\n/// This system handles mouse click detection and callback execution for\n/// entities with `Pickable` components. It operates in two phases: first\n/// checking UI entities, then querying world entities through the quadtree\n/// spatial partitioning system. For each intersecting entity, it triggers the\n/// appropriate mouse event callbacks based on the current mouse button states.\n///\n/// Parameters:\n///\n/// * `backend` : The system backend providing access to zoom level and other\n///   system state.\n///\n/// Example:\n///\n/// ```notest\n/// // Create a pickable entity\n/// let entity = @system.Entity::new()\n/// let pickable = Pickable::new()\n/// pickable.on_just_pressed(fn(button) { \n///   println(\"Clicked with button: \\{button}\") \n/// })\n/// pickables[entity] = pickable\n///\n/// // The system will automatically detect clicks on this entity\n/// // when pickable_click_system is called each frame\n/// pickable_click_system(backend)\n/// ```\n///\npub fn pickable_click_system(backend : &@system.Backend) -> Unit {\n  let zoom = backend.get_zoom()\n  let box = @math.Rect::{\n    size: @math.Vec2D(1.0, 1.0),\n    position: @system.mouse.pos * Vec2D(1 / zoom, 1 / zoom),\n  }\n  for e, _ui in @ui.uis {\n    guard e.is_alive() else { continue }\n    guard pickables.get(e) is Some(pick) else { continue }\n    guard @position.positions.get(e) is Some(position)\n    guard shapes.get(e) is Some(shape) else { continue }\n    guard shape is Rect(size=Vec2D(width, height), offset~)\n    let area_box = @math.Rect::{\n      size: @math.Vec2D(width, height),\n      position: position.0 + offset,\n    }\n    if !box.intersects(area_box) {\n      continue\n    }\n    for button in [@system.MouseButton::Left, Right, Middle] {\n      if @system.is_mouse_pressed(button) {\n        for callback in pick.on_pressed_callbacks {\n          callback(button)\n        }\n      }\n      if @system.is_mouse_released(button) {\n        for callback in pick.on_released_callbacks {\n          callback(button)\n        }\n      }\n      if @system.is_mouse_just_pressed(button) {\n        for callback in pick.on_just_pressed_callbacks {\n          callback(button)\n        }\n      }\n      if @system.is_mouse_just_released(button) {\n        for callback in pick.on_just_released_callbacks {\n          callback(button)\n        }\n      }\n    }\n  }\n  let entities = quadtree_query(box)\n  for e in entities {\n    guard e.is_alive() else { continue }\n    guard pickables.get(e) is Some(pick) else { continue }\n    guard @position.positions.get(e) is Some(position)\n    guard shapes.get(e) is Some(shape) else { continue }\n    guard shape is Rect(size=Vec2D(width, height), offset~)\n    let area_box = @math.Rect::{\n      size: @math.Vec2D(width, height),\n      position: position.0 + offset,\n    }\n    if !box.shift(@camera.get_position()).intersects(area_box) {\n      continue\n    }\n    for button in [@system.MouseButton::Left, Right, Middle] {\n      if @system.is_mouse_pressed(button) {\n        for callback in pick.on_pressed_callbacks {\n          callback(button)\n        }\n      }\n      if @system.is_mouse_released(button) {\n        for callback in pick.on_released_callbacks {\n          callback(button)\n        }\n      }\n      if @system.is_mouse_just_pressed(button) {\n        for callback in pick.on_just_pressed_callbacks {\n          callback(button)\n        }\n      }\n      if @system.is_mouse_just_released(button) {\n        for callback in pick.on_just_released_callbacks {\n          callback(button)\n        }\n      }\n    }\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// FIXME: This should be the same as the WORLD_WIDTH\n\n// FIXME: quadtree should be able to rebuild\n\n///|\npub let quadtree_root : Ref[QuadTree] = Ref::new(\n  QuadTree::new(@math.Vec2D(0, 0), @math.Vec2D(0, 0), 0),\n)\n\n///|\npub struct QuadTree {\n  position : @math.Vec2D\n  size : @math.Vec2D\n  children : Array[QuadTree]\n  priv depth : Int\n  priv bounding_box : @math.Rect\n  priv entities : @set.Set[@system.Entity]\n}\n\n///|\nfn QuadTree::new(\n  position : @math.Vec2D,\n  size : @math.Vec2D,\n  depth : Int,\n) -> QuadTree {\n  {\n    position,\n    size,\n    depth,\n    entities: @set.Set::new(),\n    children: [],\n    bounding_box: { position, size },\n  }\n}\n\n///|\nfn QuadTree::is_smallest_size(self : QuadTree) -> Bool {\n  self.size[X] <= SMALLEST_SIZE || self.size[Y] <= SMALLEST_SIZE\n}\n\n///|\nconst SMALLEST_SIZE = 64.0\n\n///|\nfn QuadTree::insert(\n  self : Self,\n  entity : @system.Entity,\n  box : @math.Rect,\n) -> Unit {\n  if !self.bounding_box.intersects(box) {\n    return\n  }\n  if self.is_smallest_size() {\n    self.entities.add(entity)\n    return\n  }\n  if self.children.is_empty() {\n    let half_size = @math.Vec2D(self.size[X] * 0.5, self.size[Y] * 0.5)\n    self.children\n    ..push(QuadTree::new(self.position, half_size, self.depth + 1))\n    ..push(\n      QuadTree::new(\n        self.position + @math.Vec2D(half_size[X], 0),\n        half_size,\n        self.depth + 1,\n      ),\n    )\n    ..push(\n      QuadTree::new(\n        self.position + @math.Vec2D(0, half_size[Y]),\n        half_size,\n        self.depth + 1,\n      ),\n    )\n    ..push(QuadTree::new(self.position + half_size, half_size, self.depth + 1))\n  }\n  for child in self.children {\n    child.insert(entity, box)\n  }\n}\n\n///|\nfn quadtree_query(area : @math.Rect) -> @set.Set[@system.Entity] {\n  let mut trees = @list.of([quadtree_root.val])\n  let mut results = @set.Set::new()\n  while trees is More(hd, tail=rest) {\n    trees = rest\n    if !hd.bounding_box.intersects(area) {\n      continue\n    }\n    if hd.children is [] {\n      results = results.union(hd.entities)\n    } else {\n      hd.children.each(t => trees = trees.add(t))\n    }\n  }\n  results\n}\n\n///|\n/// Renders the quadtree structure for debugging purposes by drawing stroke\n/// rectangles for each node.\n///\n/// Parameters:\n///\n/// * `backend` : The rendering backend used to draw the quadtree visualization.\n///\n/// Example:\n///\n/// ```notest\n/// // In a game loop or debugging context\n/// quadtree_render_system(backend)\n/// // This will draw blue stroke rectangles showing the quadtree partitioning\n/// ```\n///\npub fn quadtree_render_system(backend : &@system.Backend) -> Unit {\n  fn render_node(node : QuadTree) -> Unit {\n    let position = node.position - @camera.get_position()\n    let size = node.size\n    backend.draw_stroke_rect(\n      x=position[X],\n      y=position[Y],\n      width=size[X],\n      height=size[Y],\n      color=\"blue\",\n    )\n    for child in node.children {\n      render_node(child)\n    }\n  }\n\n  render_node(quadtree_root.val)\n}\n\n///|\npub fn quadtree_clear_system(_ : &@system.Backend) -> Unit {\n  let mut left_limit = 0.0\n  let mut right_limit = 0.0\n  let mut top_limit = 0.0\n  let mut bottom_limit = 0.0\n  let boxes = []\n  for e, shape in shapes {\n    guard e.is_alive() else { continue }\n    guard @ui.uis.get(e) is None else { continue }\n    guard @position.positions.get(e) is Some(position) else { continue }\n    guard shape is Rect(size=Vec2D(width, height), offset~) else { continue }\n    let box = @math.Rect::{\n      position: position.0 + offset,\n      size: @math.Vec2D(width, height),\n    }\n    boxes.push((e, box))\n    left_limit = @cmp.minimum(left_limit, box.position[X])\n    right_limit = @cmp.maximum(right_limit, box.position[X] + box.size[X])\n    top_limit = @cmp.minimum(top_limit, box.position[Y])\n    bottom_limit = @cmp.maximum(bottom_limit, box.position[Y] + box.size[Y])\n  }\n  quadtree_root.val = QuadTree::new(\n    @math.Vec2D(left_limit, top_limit),\n    @math.Vec2D(right_limit - left_limit, bottom_limit - top_limit),\n    0,\n  )\n  for box in boxes {\n    quadtree_root.val.insert(box.0, box.1)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Collision detector component for entities in the physics system.\n///\n/// Collider components define how entities interact with other entities in the\n/// collision detection system. Each collider has a collision layer that\n/// determines what it is, a collision mask that determines what it can collide\n/// with, and an active flag to enable or disable collision detection.\n///\n/// Fields:\n///\n/// * `active` : Whether collision detection is enabled for this collider.\n/// * `layer` : The collision layer this collider belongs to.\n/// * `mask` : The collision mask defining which layers this collider can\n///   interact with.\n///\n/// Example:\n///\n/// ```notest\n/// let layer = @collision.CollisionLayer::new()\n/// let mask = @collision.CollisionMask::new([layer])\n/// let collider = @collision.Collider::new(layer, mask)\n///\n/// // Access fields\n/// inspect(collider.active, content=\"true\")\n/// println(\"Layer: \\{collider.layer}\")\n/// println(\"Mask layers: \\{collider.mask.inner().length()}\")\n///\n/// // Modify active state\n/// collider.active = false\n/// ```\n///\npub(all) struct Collider {\n  mut active : Bool\n  mask : CollisionMask\n}\n\n///|\n/// Creates a new collider with the specified collision layer and mask.\n///\n/// Parameters:\n///\n/// * `layer` : The collision layer this collider belongs to, determining what\n///   category of collision object this is.\n/// * `mask` : The collision mask defining which collision layers this collider\n///   can interact with.\n///\n/// Returns a new `Collider` instance with collision detection enabled by\n/// default.\n///\n/// Example:\n///\n/// ```notest\n/// let layer = @collision.CollisionLayer::new()\n/// let mask = @collision.CollisionMask::new([layer])\n/// let collider = @collision.Collider::new(layer, mask)\n/// inspect(collider.active, content=\"true\")\n/// ```\n///\npub fn Collider::new(mask : CollisionMask) -> Collider {\n  { active: true, mask }\n}\n\n///|\n/// Global storage for all collider components in the collision system.\n///\n/// This map stores the association between entities and their collider\n/// components. Each entity that participates in collision detection must have\n/// an entry in this map. The collision system uses this map to determine which\n/// entities can collide with each other based on their collision masks and\n/// layers.\n///\n/// Do not manually modify this map directly. Instead, use the collision\n/// system's APIs to add, remove, or modify colliders for entities. The\n/// collision detection systems automatically query this map during collision\n/// processing.\n///\n/// Example:\n///\n/// ```notest\n/// // Check if an entity has a collider\n/// let entity = @system.Entity::new()\n/// if @collision.colliders.contains(entity) {\n///   let collider = @collision.colliders.get(entity).unwrap()\n///   println(\"Entity has collider with active status: \\{collider.active}\")\n/// }\n/// ```\n///\npub let colliders : Map[@system.Entity, Collider] = Map::new()\n\n///|\n/// The collision info represents information about a collision event.\n/// \npub struct CollisionInfo {\n  entity : @system.Entity\n  direction : @math.Vec2D\n}\n\n///|\n/// `@collision.collision_infos.get(ENTITY)` is an array of `CollisionInfo`\n/// objects that represent the collisions of the entity with other entities.\n/// Do not manually modify this map; it is managed by the collision system.\n/// \nlet collision_infos : Map[@system.Entity, Array[CollisionInfo]] = Map::new()\n\n///|\nfn add_collision_info(\n  entity : @system.Entity,\n  target : @system.Entity,\n  direction : @math.Vec2D,\n) -> Unit {\n  if collision_infos.get(entity) is None {\n    collision_infos.set(entity, Array::new())\n  }\n  collision_infos.get(entity).unwrap().push({ entity: target, direction })\n}\n\n///|\n/// Get all collision infos for a specific entity.\n/// This function returns an empty array if there are no collision infos for the entity.\n///\npub fn get_collision_infos(entity : @system.Entity) -> Array[CollisionInfo] {\n  collision_infos.get(entity).unwrap_or_default()\n}\n\n///|\n/// Checks if the entity is on the floor. \n/// Returns `true` if the entity is colliding with the floor,\n/// which is defined as having a collision direction with a positive Y component.\n/// \npub fn is_on_floor(entity : @system.Entity) -> Bool {\n  let infos = get_collision_infos(entity)\n  for info in infos {\n    if info.direction[Y] > 0 {\n      return true\n    }\n  }\n  return false\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// The `CollisionLayer` struct represents a layer that defines the collision\n/// properties of a collision object. It is used to categorize collision objects\n/// into different layers, allowing for more granular control over collision detection.\n///\npub struct CollisionLayer(UInt) derive(Eq)\n\n///|\n/// The `CollisionMask` struct represents a mask that defines which collision layers\n/// a collision object can interact with. It is used to filter collisions based on\n/// the layers of the objects involved in the collision.\n/// \npub struct CollisionMask(Array[CollisionLayer])\n\n///|\nlet collision_layer_generator : Ref[UInt] = { val: 0 }\n\n///|\n/// Creates a new `CollisionLayer` with a unique identifier.\n/// \npub fn CollisionLayer::new() -> CollisionLayer {\n  let layer = collision_layer_generator.val\n  collision_layer_generator.val += 1\n  layer\n}\n\n///|\n/// Global registry that maps entities to their assigned collision layers.\n///\n/// This registry maintains the association between entities and their collision\n/// layers, allowing the collision system to determine which layer each entity\n/// belongs to for collision detection and filtering purposes. Entities can be\n/// assigned to different collision layers to control how they interact with\n/// other entities in the collision system.\n///\n/// Example:\n///\n/// ```notest\n/// let player_layer = @collision.CollisionLayer::new()\n/// let enemy_layer = @collision.CollisionLayer::new()\n///\n/// // Assign collision layers to entities\n/// @collision.collision_layers[player_entity] = player_layer\n/// @collision.collision_layers[enemy_entity] = enemy_layer\n///\n/// // Check which layer an entity belongs to\n/// match @collision.collision_layers.get(player_entity) {\n///   Some(layer) => println(\"Player is on collision layer\")\n///   None => println(\"Player has no collision layer assigned\")\n/// }\n/// ```\n///\npub let collision_layers : Map[@system.Entity, CollisionLayer] = Map::new()\n\n///|\n/// Creates a new `CollisionMask` with the specified layers \n/// that the collision object can interact with.\n/// \npub fn CollisionMask::new(layers : Array[CollisionLayer]) -> CollisionMask {\n  layers\n}\n\n///|\n/// Creates an empty `CollisionMask` that does not interact with any layers.\n/// \npub fn CollisionMask::empty() -> CollisionMask {\n  []\n}\n\n///|\nfn CollisionMask::contains(\n  self : CollisionMask,\n  layer : CollisionLayer,\n) -> Bool {\n  self.0.contains(layer.0)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Move all entities with velocity, modify positions and handle collisions.\n/// Note: 1. This system should be run after any acceleration system.\n///       2. This system will query a quadtree to find collisions.\n///       3. This system will set real_velocities of entities.\n/// \npub fn move_system(_backend : &@system.Backend) -> Unit {\n  collision_infos.clear()\n  for e, vel in @velocity.velocities {\n    guard e.is_alive() else { continue }\n    if colliders.get(e) is Some(collide) && collide.active {\n      move_with_collide(e, collide, vel.0)\n    } else {\n      move_without_collide(e, vel.0)\n    }\n  }\n}\n\n///|\nfn move_without_collide(e : @system.Entity, velocity : @math.Vec2D) -> Unit {\n  guard @position.positions.get(e) is Some(pos)\n  let new_pos = @math.Vec2D(pos.0[X] + velocity[X], pos.0[Y] + velocity[Y])\n  @position.positions.set(e, new_pos)\n  real_velocities.set(e, velocity)\n}\n\n///|\nfn move_with_collide(\n  e : @system.Entity,\n  collide : Collider,\n  velocity : @math.Vec2D,\n) -> Unit {\n  guard @position.positions.get(e) is Some(pos)\n  guard shapes.get(e) is Some(shape)\n  guard shape is Rect(size=Vec2D(width, height), offset~)\n  let box = @math.Rect::{\n    position: pos.0 + offset,\n    size: @math.Vec2D(width, height),\n  }\n  let new_x = move_axis(e, box, velocity, X, collide.mask)\n  let object_x = @math.Rect::{ size: box.size, position: new_x.0 }\n  let new_y = move_axis(e, object_x, new_x.1, Y, collide.mask)\n  @position.positions.set(e, new_y.0 - offset)\n  real_velocities.set(e, new_y.1)\n}\n\n///|\npub let real_velocities : Map[@system.Entity, @velocity.Velocity] = Map::new()\n\n///|\nfn make_ray_collision(\n  object : @math.Rect,\n  speed : Double,\n  axis : @math.Axis,\n) -> @math.Rect {\n  let pos = @math.Vec2D(object.position[X], object.position[Y])\n  let size = @math.Vec2D(object.size[X], object.size[Y])\n  if speed >= 0 {\n    { position: pos, size: size.update(axis, size[axis] + speed) }\n  } else {\n    {\n      position: pos.update(axis, pos[axis] + speed),\n      size: size.update(axis, size[axis] - speed),\n    }\n  }\n}\n\n///|\n/// Move object with velocity, returns the destination and updated velocity.\nfn move_axis(\n  entity : @system.Entity,\n  object : @math.Rect,\n  velocity : @math.Vec2D,\n  axis : @math.Axis,\n  mask : CollisionMask,\n) -> (@math.Vec2D, @math.Vec2D) {\n  let ray_collision = make_ray_collision(object, velocity[axis], axis)\n  let mut new_pos = @math.Vec2D(object.position[X], object.position[Y])\n  new_pos = new_pos.update(axis, new_pos[axis] + velocity[axis])\n  let mut new_velocity = velocity\n  let entities = quadtree_query(ray_collision)\n  for e in entities {\n    guard e.is_alive() else { continue }\n    guard e != entity else { continue }\n    guard shapes.get(e) is Some(shape) else { continue }\n    guard shape is Rect(size=Vec2D(width, height), offset~) else { continue }\n    guard @position.positions.get(e) is Some(pos) else { continue }\n    guard collision_layers.get(e) is Some(collision_layer) else { continue }\n    guard mask.contains(collision_layer) else { continue }\n    let collision_box = @math.Rect::{\n      size: @math.Vec2D(width, height),\n      position: pos.0 + offset,\n    }\n    if object.intersects(collision_box) {\n      let movement = aabb_resolve(object, collision_box)\n      new_pos = new_pos + movement\n      let dir = @math.Vec2D::zero().update(\n        axis,\n        if movement[axis] > 0.0 {\n          1.0\n        } else {\n          -1.0\n        },\n      )\n      add_collision_info(entity, e, dir)\n      return (new_pos, movement)\n    }\n    if @math.Rect::intersects(ray_collision, collision_box) {\n      let mut dir = @math.Vec2D(0, 0)\n      if new_velocity[axis] > 0 {\n        new_pos = new_pos.update(\n          axis,\n          @cmp.maximum(\n            collision_box.position[axis] - object.size[axis],\n            object.position[axis],\n          ),\n        )\n        new_velocity = new_velocity.update(\n          axis,\n          new_pos[axis] - object.position[axis],\n        )\n        dir = dir.update(axis, 1.0)\n      } else if new_velocity[axis] < 0 {\n        new_pos = new_pos.update(\n          axis,\n          @cmp.minimum(\n            collision_box.position[axis] + collision_box.size[axis],\n            object.position[axis],\n          ),\n        )\n        new_velocity = new_velocity.update(\n          axis,\n          new_pos[axis] - object.position[axis],\n        )\n        dir = dir.update(axis, -1.0)\n      }\n      add_collision_info(entity, e, dir)\n    }\n  }\n  return (new_pos, new_velocity)\n}\n\n///|\nfn aabb_resolve(a : @math.Rect, b : @math.Rect) -> @math.Vec2D {\n  let a_center = a.position + a.size.scalar_mul(0.5)\n  let b_center = b.position + b.size.scalar_mul(0.5)\n  let a_half = a.size.scalar_mul(0.5)\n  let b_half = b.size.scalar_mul(0.5)\n  let delta = b_center - a_center\n  let intersect = @math.Vec2D(\n    delta[X].abs() - (b_half[X] + a_half[X]),\n    delta[Y].abs() - (b_half[Y] + a_half[Y]),\n  )\n  if intersect[X] > intersect[Y] {\n    if delta[X] > 0 {\n      @math.Vec2D(intersect[X], 0.0)\n    } else {\n      @math.Vec2D(-intersect[X], 0.0)\n    }\n  } else if delta[Y] > 0 {\n    @math.Vec2D(0.0, intersect[Y])\n  } else {\n    @math.Vec2D(0.0, -intersect[Y])\n  }\n}\n\n///|\ntest \"AABB resolve\" {\n  let a = @math.Rect::{ position: @math.Vec2D(0, 0), size: @math.Vec2D(32, 32) }\n  let b = @math.Rect::{\n    position: @math.Vec2D(16, 16),\n    size: @math.Vec2D(32, 32),\n  }\n  let movement = aabb_resolve(a, b)\n  inspect(movement, content=\"Vec2D(0, -16)\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub typealias () -> Unit as Event\n\n///|\n/// Stores a collection of events that will be executed in a deferred manner\n/// during the next frame.\n///\n/// This array acts as a queue for events that need to be processed later,\n/// typically used in game development scenarios where certain operations need\n/// to be delayed until the appropriate system update cycle. Events are added to\n/// this collection via `defer_event` and processed by `deferred_event_system`.\n///\n/// The array is automatically cleared after all deferred events have been\n/// executed in each frame, ensuring that events are only processed once and the\n/// queue doesn't accumulate stale events across multiple frames.\n///\nlet deferred_events : Array[Event] = Array::new()\n\n///|\n/// Processes all deferred events and clears the event queue.\n///\n/// Executes all events that have been added to the deferred events queue during\n/// the current frame cycle, then removes them from the queue to prepare for the\n/// next frame. This system is typically called once per frame to handle events\n/// that need to be processed in a delayed manner.\n///\n/// Parameters:\n///\n/// * `backend` : The backend instance used for rendering and system operations\n///   (unused in this implementation).\n/// \n/// Usage:\n/// \n/// ```notest\n/// app.add_system(@camera.deferred_event_system)\n/// ```\n///\n/// Example:\n///\n/// ```notest\n/// // Add some events to be processed later\n/// defer_event(fn() { println(\"First event\") })\n/// defer_event(fn() { println(\"Second event\") }) \n/// ```\n/// \npub fn deferred_event_system(_backend : &Backend) -> Unit {\n  while deferred_events.pop() is Some(event) {\n    event()\n  }\n}\n\n///|\n/// Adds an event to the deferred events queue to be executed in the next frame.\n///\n/// Parameters:\n///\n/// * `event` : The event function to be executed later.\n///\n/// Example:\n///\n/// ```notest\n/// // Schedule a simple logging event\n/// @system.defer_event(fn() { println(\"This will be executed next frame\") })\n///\n/// // Schedule an event that modifies game state\n/// @system.defer_event(fn() { \n///   // Some game logic that needs to be delayed\n///   player.respawn()\n/// })\n/// ```\n///\npub fn defer_event(event : Event) -> Unit {\n  deferred_events.push(event)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct Area {\n  mask : CollisionMask\n  on_enter_callbacks : Array[(@system.Entity) -> Unit]\n  on_exit_callbacks : Array[(@system.Entity) -> Unit]\n  mut contains : Set[@system.Entity]\n}\n\n///|\n/// Creates a new collision area with the specified layer and collision mask.\n///\n/// Parameters:\n///\n/// * `layer` : The collision layer that this area belongs to.\n/// * `mask` : The collision mask that determines which collision layers this\n///   area can interact with.\n///\n/// Returns a new `Area` instance with empty callback lists and no previously\n/// contained entities.\n///\n/// Example:\n///\n/// ```notest\n/// let layer = @collision.CollisionLayer::new()\n/// let mask = @collision.CollisionMask::empty()\n/// let area = @collision.Area::new(layer, mask)\n/// ```\n///\npub fn Area::new(mask : CollisionMask) -> Area {\n  { mask, contains: Set::new(), on_enter_callbacks: [], on_exit_callbacks: [] }\n}\n\n///|\npub let areas : Map[@system.Entity, Area] = Map::new()\n\n///|\n/// Retrieves the set of entities currently contained within the specified area\n/// entity.\n///\n/// Parameters:\n///\n/// * `area` : The entity that has an area component whose contained entities\n///   should be retrieved.\n///\n/// Returns a `Set[@system.Entity]` containing all entities currently within the\n/// area. If the specified entity does not have an area component, returns an\n/// empty set.\n///\n/// Example:\n///\n/// ```notest\n/// // Create an area entity\n/// let area_entity = @system.Entity::new()\n/// let layer = @collision.CollisionLayer::new()\n/// let mask = @collision.CollisionMask::empty()\n/// let area = @collision.Area::new(layer, mask)\n/// @collision.areas.set(area_entity, area)\n///\n/// // Get entities contained in the area\n/// let contained_entities = @collision.get_contains(area_entity)\n/// println(\"Area contains \\{contained_entities.length()} entities\")\n/// ```\n///\npub fn get_contains(area : @system.Entity) -> Set[@system.Entity] {\n  areas.get(area).map_or(Set::new(), fn(area) { area.contains })\n}\n\n///|\n/// Registers a callback function to be executed when another entity enters this\n/// area.\n///\n/// Parameters:\n///\n/// * `self` : The area to register the callback on.\n/// * `callback` : A function that will be called with the entering entity as\n///   its argument.\n///\n/// Example:\n///\n/// ```notest\n/// let layer = @collision.CollisionLayer::new()\n/// let mask = @collision.CollisionMask::empty()\n/// let shape = @collision.CollisionShape::Rect(size=@math.Vec2D(100.0, 100.0), offset=@math.Vec2D(0.0, 0.0))\n/// let area = @collision.Area::new(shape, layer, mask)\n/// area.on_enter(fn(entity) { println(\"Entity \\{entity} entered the area!\") })\n/// @collision.areas.set(my_entity, area)\n/// ```\n///\npub fn Area::on_enter(self : Area, callback : (@system.Entity) -> Unit) -> Unit {\n  self.on_enter_callbacks.push(callback)\n}\n\n///|\n/// Registers a callback function to be executed when another entity exits this\n/// area.\n///\n/// Parameters:\n///\n/// * `self` : The area to register the callback on.\n/// * `callback` : A function that will be called with the exiting entity as its\n///   argument.\n///\n/// Example:\n///\n/// ```notest\n/// let layer = @collision.CollisionLayer::new()\n/// let mask = @collision.CollisionMask::empty()\n/// let area = @collision.Area::new(layer, mask)\n/// area.on_exit(fn(entity) { println(\"Entity \\{entity} exited the area!\") })\n/// @collision.areas.set(my_entity, area)\n/// ```\n///\npub fn Area::on_exit(self : Area, callback : (@system.Entity) -> Unit) -> Unit {\n  self.on_exit_callbacks.push(callback)\n}\n\n///|\n/// Processes collision detection between area entities and other entities in\n/// the game world using spatial partitioning for efficient queries.\n///\n/// Parameters:\n///\n/// * `backend` : The system backend instance (unused in the current\n///   implementation).\n///\n/// Panics if an entity has an area component but lacks a position component, or\n/// if an entity has an area component but lacks a collision shape component.\n///\n/// Example:\n///\n/// ```notest\n/// // Set up entities with area and collide components\n/// let entity1 = @system.Entity::new()\n/// let entity2 = @system.Entity::new()\n///\n/// // Create area for entity1\n/// let layer1 = @collision.CollisionLayer::new()\n/// let mask1 = @collision.CollisionMask::new([layer1])\n/// let area1 = @collision.Area::new(layer1, mask1)\n/// area1.on_enter(fn(entity) { println(\"Entity entered area!\") })\n/// @collision.areas.set(entity1, area1)\n///\n/// // Create collide component for entity2\n/// let layer2 = @collision.CollisionLayer::new()\n/// let mask2 = @collision.CollisionMask::new([layer2])\n/// let collide2 = @collision.Collide::{ shape: @collision.CollisionShape::Rect(size=@math.Vec2D(50.0, 50.0), offset=@math.Vec2D(0.0, 0.0)), layer: layer2, mask: mask2 }\n/// @collision.collides.set(entity2, collide2)\n///\n/// // Run the collision system\n/// @collision.area_collide_system(backend)\n/// ```\n///\npub fn area_collide_system(_ : &@system.Backend) -> Unit {\n  for e in @system.iter_entities() {\n    guard areas.get(e) is Some(area) else { continue }\n    guard @position.positions.get(e) is Some(position)\n    guard shapes.get(e) is Some(shape) else { continue }\n    guard shape is Rect(size=Vec2D(width, height), offset~)\n    let box = @math.Rect::{\n      size: @math.Vec2D(width, height),\n      position: position.0 + offset,\n    }\n    let new_contains = Set::new()\n    let entities = quadtree_query(box)\n    for entity in entities {\n      guard entity.is_alive() else { continue }\n      guard collision_layers.get(entity) is Some(other_layer) else { continue }\n      guard shapes.get(entity) is Some(other_shape) else { continue }\n      guard other_shape\n        is Rect(size=Vec2D(other_width, other_height), offset=other_offset)\n      guard @position.positions.get(entity) is Some(other_position)\n      let other_box = @math.Rect::{\n        size: @math.Vec2D(other_width, other_height),\n        position: other_position.0 + other_offset,\n      }\n      guard box.intersects(other_box) else { continue }\n      guard area.mask.contains(other_layer) else { continue }\n      new_contains.add(entity)\n      if area.contains.contains(entity) {\n        continue\n      }\n      for callback in area.on_enter_callbacks {\n        callback(entity)\n      }\n    }\n    for entity in area.contains {\n      if new_contains.contains(entity) {\n        continue\n      }\n      for callback in area.on_exit_callbacks {\n        callback(entity)\n      }\n    }\n    area.contains = new_contains\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npriv struct FrameTimer {\n  mut rest : Int\n  callback : () -> Unit\n}\n\n///|\nlet timers : Array[FrameTimer] = Array::new()\n\n///|\npub fn timeout_with_frames(frames : Int, callback : () -> Unit) -> Unit {\n  timers.push({ rest: frames, callback })\n}\n\n///|\npub fn timer_system(_backend : &Backend) -> Unit {\n  for timer in timers {\n    timer.rest -= 1\n    if timer.rest <= 0 {\n      (timer.callback)()\n    }\n  }\n  timers.retain(fn(timer) { timer.rest > 0 })\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n// Battle System - 整合所有战斗相关功能\n// 包含：战斗渲染、输入处理、状态管理、场景生成、菜单配置、布局\n\n///|\n// ===== 战斗系统常量 =====\nconst BATTLE_SCREEN_WIDTH : Double = 800.0\nconst BATTLE_SCREEN_HEIGHT : Double = 600.0\nconst POKEMON_SIZE : Double = 200.0\nconst UI_PANEL_HEIGHT : Double = 150.0\n\n// 新增常量\nconst BATTLE_ARENA_HEIGHT : Double = 450.0  // 战斗区域高度\nconst PLATFORM_WIDTH : Double = 120.0       // 平台宽度\nconst PLATFORM_HEIGHT : Double = 60.0       // 平台高度\n\n///|\n// ===== 战斗状态结构 =====\n\n///|\n// 战斗渲染状态\npub struct BattleRenderState {\n  player_pokemon_entity : @system.Entity\n  enemy_pokemon_entity : @system.Entity\n  background_entity : @system.Entity\n  ui_panel_entity : @system.Entity\n  text_box_entity : @system.Entity\n  text_entity : @system.Entity\n  menu_entity : @system.Entity\n  mut selected_option : MenuOption\n  is_active : Bool\n  current_selection_entity : @system.Entity\n  mut skill_menu_visible : Bool\n  mut skill_menu_selected : Int\n  // 添加当前宝可梦数据\n  mut current_player_pokemon : Option[Pokemon]\n  mut current_enemy_pokemon : Option[Pokemon]\n  // 新增：回合制相关\n  mut battle_state : Option[BattleState]\n  // 新增：宝可梦信息显示\n  mut player_pokemon_info : Option[PokemonInfoEntities]\n  mut enemy_pokemon_info : Option[PokemonInfoEntities]\n} derive(Show)\n\n///|\n// 战斗菜单配置\nstruct BattleMenuConfig {\n  // 主战斗菜单配置\n  main_menu : MainMenuConfig\n  \n  // 技能菜单配置\n  skill_menu : SkillMenuConfig\n  \n  // 屏幕尺寸配置\n  screen : ScreenConfig\n  \n  // 布局配置\n  layout : LayoutConfig\n}\n\n///|\n// 主战斗菜单配置\nstruct MainMenuConfig {\n  // 基础属性\n  visible : Bool\n  selected_index : Int\n  selected_option : MenuOption\n  \n  // 几何属性\n  mut position : @math.Vec2D\n  mut width : Double\n  mut height : Double\n  \n  // 样式配置\n  background_color : String\n  border_color : String\n  text_color : String\n  indicator_color : String\n  \n  // 按钮配置\n  button_spacing : Double\n  button_height : Double\n  button_padding : Double\n}\n\n///|\n// 技能菜单配置\nstruct SkillMenuConfig {\n  // 基础属性\n  visible : Bool\n  selected_index : Int\n  \n  // 几何属性\n  mut position : @math.Vec2D\n  mut width : Double\n  mut height : Double\n  \n  // 样式配置\n  background_color : String\n  border_color : String\n  text_color : String\n  indicator_color : String\n  title_color : String\n  \n  // 技能项配置\n  skill_spacing : Double\n  skill_height : Double\n  skill_padding : Double\n  title_height : Double\n}\n\n///|\n// 屏幕配置\nstruct ScreenConfig {\n  width : Double\n  height : Double\n  title_height : Double\n  prompt_height : Double\n}\n\n///|\n// 布局配置\nstruct LayoutConfig {\n  // 边距和间距\n  margin : Double\n  padding : Double\n  \n  // 区域尺寸\n  enemy_area_width : Double\n  enemy_area_height : Double\n  player_area_width : Double\n  player_area_height : Double\n  menu_area_width : Double\n  menu_area_height : Double\n  status_area_width : Double\n  status_area_height : Double\n  \n  // 位置偏移\n  title_offset_y : Double\n  enemy_offset_y : Double\n  player_offset_y : Double\n  menu_offset_y : Double\n  status_offset_y : Double\n}\n\n///|\n// 菜单选项枚举\npub enum MenuOption {\n  Fight\n  Bag\n  Pokemon\n  Run\n} derive(Show, Eq)\n\n///|\n// 输入类型枚举\nenum InputType {\n  Keyboard\n  Mouse\n  Touch\n  Gamepad\n} derive(Show)\n\n///|\n// 按键状态\nenum KeyState {\n  Pressed\n  Released\n  Held\n  None\n} derive(Eq)\n\n///|\n// 鼠标按钮\nenum MouseButton {\n  Left\n  Right\n  Middle\n} derive(Eq, Hash, Show)\n\n///|\n// 触摸手势\nenum TouchGesture {\n  Tap\n  DoubleTap\n  LongPress\n  Swipe\n  Pinch\n} derive(Show)\n\n///|\n// 输入事件结构\nstruct InputEvent {\n  input_type: InputType\n  key: String\n  position: @math.Vec2D\n  timestamp: Double\n  data: Map[String, String]\n}\n\n///|\n// 输入处理器\nstruct BattleInputHandler {\n  mut is_enabled: Bool\n  key_states: Map[String, KeyState]\n  mut mouse_position: @math.Vec2D\n  mouse_buttons: Map[MouseButton, Bool]\n  \n  // 事件队列\n  event_queue: Array[InputEvent]\n  \n  // 回调函数\n  mut on_key_press: Option[(String) -> Unit]\n  on_key_release: Option[(String) -> Unit]\n  mut on_mouse_click: Option[(String) -> Unit]\n  on_mouse_move: Option[(String) -> Unit]\n  on_touch_gesture: Option[(String) -> Unit]\n}\n\n///|\n// ===== 全局实例 =====\n\n///|\n// 全局战斗渲染状态\nlet battle_render_state : BattleRenderState = BattleRenderState::{\n  player_pokemon_entity: @system.Entity::new(),\n  enemy_pokemon_entity: @system.Entity::new(),\n  background_entity: @system.Entity::new(),\n  ui_panel_entity: @system.Entity::new(),\n  text_box_entity: @system.Entity::new(),\n  text_entity: @system.Entity::new(),\n  menu_entity: @system.Entity::new(),\n  selected_option: MenuOption::Fight,\n  is_active: false,\n  current_selection_entity: @system.Entity::new(),\n  skill_menu_visible: false,\n  skill_menu_selected: 0,\n  current_player_pokemon: None,\n  current_enemy_pokemon: None,\n  battle_state: None,\n  player_pokemon_info: None,\n  enemy_pokemon_info: None\n}\n\n///|\n// 全局指示器实体\nlet global_indicator_entity : @system.Entity = @system.Entity::new()\n\n///|\n// 全局战斗菜单配置实例\nlet battle_menu_config : BattleMenuConfig = {\n  // 主菜单配置\n  main_menu: MainMenuConfig::{\n    visible: false,\n    selected_index: 0,\n    selected_option: Fight,\n    position: @math.Vec2D(50.0, 450.0),\n    width: 170.0,\n    height: 115.0,\n    background_color: \"#1a1a1a\",\n    border_color: \"#4ECDC4\",\n    text_color: \"#FFFFFF\",\n    indicator_color: \"#4ECDC4\",\n    button_spacing: 25.0,\n    button_height: 20.0,\n    button_padding: 10.0\n  },\n  \n  // 技能菜单配置\n  skill_menu: SkillMenuConfig::{\n    visible: false,\n    selected_index: 0,\n    position: @math.Vec2D(250.0, 450.0),\n    width: 220.0,\n    height: 200.0,\n    background_color: \"#1a1a1a\",\n    border_color: \"#4ECDC4\",\n    text_color: \"#FFFFFF\",\n    indicator_color: \"#4ECDC4\",\n    title_color: \"#FFFFFF\",\n    skill_spacing: 30.0,\n    skill_height: 25.0,\n    skill_padding: 25.0,\n    title_height: 20.0\n  },\n  \n  // 屏幕配置\n  screen: ScreenConfig::{\n    width: 800.0,\n    height: 600.0,\n    title_height: 32.0,\n    prompt_height: 18.0\n  },\n  \n  // 布局配置\n  layout: LayoutConfig::{\n    margin: 20.0,\n    padding: 15.0,\n    enemy_area_width: 120.0,\n    enemy_area_height: 100.0,\n    player_area_width: 120.0,\n    player_area_height: 100.0,\n    menu_area_width: 200.0,\n    menu_area_height: 120.0,\n    status_area_width: 100.0,\n    status_area_height: 80.0,\n    title_offset_y: 20.0,\n    enemy_offset_y: 50.0,\n    player_offset_y: 50.0,\n    menu_offset_y: 170.0,\n    status_offset_y: 170.0\n  }\n}\n\n///|\n// 全局输入处理器实例\nlet input_handler: BattleInputHandler = {\n  is_enabled: true,\n  key_states: Map::new(),\n  mouse_position: @math.Vec2D(0.0, 0.0),\n  mouse_buttons: Map::new(),\n  event_queue: Array::new(),\n  on_key_press: None,\n  on_key_release: None,\n  on_mouse_click: None,\n  on_mouse_move: None,\n  on_touch_gesture: None,\n}\n\n///|\n// ===== 战斗渲染功能 =====\n\n///|\n// 获取当前选择\nfn get_current_selection() -> MenuOption {\n  battle_render_state.selected_option\n}\n\n///|\n// 更新指示器位置\nfn update_indicator_position(selection : MenuOption) -> Unit {\n  // 按钮位置（基于battle_render.mbt中的实际位置）：\n  // 战斗: (550, 485) - 左上\n  // 背包: (670, 485) - 右上  \n  // 宝可梦: (550, 520) - 左下\n  // 逃跑: (670, 520) - 右下\n  \n  // 箭头应该放在按钮左侧，稍微偏左一点\n  let indicator_pos = match selection {\n    MenuOption::Fight => @math.Vec2D(530.0, 485.0)    // 战斗按钮左侧\n    MenuOption::Bag => @math.Vec2D(650.0, 485.0)     // 背包按钮左侧\n    MenuOption::Pokemon => @math.Vec2D(530.0, 520.0)  // 宝可梦按钮左侧\n    MenuOption::Run => @math.Vec2D(650.0, 520.0)      // 逃跑按钮左侧\n  }\n  \n  // 更新指示器位置\n  @position.positions.set(global_indicator_entity, indicator_pos)\n  \n  // 如果指示器还没有精灵，创建一个\n  if @sprite.sprites.get(global_indicator_entity) is None {\n    let indicator_sprite = @sprite.Sprite::from_text(\n      @sprite.Text::new(\n        \"▶\",\n        color=\"#FFFF00\",\n        font=\"16px Arial\"\n      ),\n      13\n    )\n    @sprite.sprites.set(global_indicator_entity, indicator_sprite)\n  }\n  \n  // 更新全局状态\n  battle_render_state.selected_option = selection\n  \n  println(\"🎯 箭头位置更新: (\" + indicator_pos.0.to_string() + \", \" + indicator_pos.1.to_string() + \") - \" + selection.to_string())\n}\n\n///|\n// 初始化全局状态\nfn init_global_state() -> Unit {\n  println(\"🌍 初始化全局状态...\")\n  \n  // 创建初始指示器\n  let indicator_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"▶\",\n      color=\"#FFFF00\",\n      font=\"16px Arial\"\n    ),\n    13\n  )\n  @sprite.sprites.set(global_indicator_entity, indicator_sprite)\n  @position.positions.set(global_indicator_entity, @math.Vec2D(530.0, 485.0))\n  \n  // 设置初始选择\n  battle_render_state.selected_option = MenuOption::Fight\n  \n  println(\"✅ 全局状态初始化完成\")\n  println(\"🎯 初始箭头位置: (530, 485) - 战斗按钮左侧\")\n}\n\n///|\n// 初始化战斗渲染系统\npub fn init_battle_render_system() -> Unit {\n  println(\"🎨 初始化战斗渲染系统...\")\n  \n  // 初始化全局状态\n  init_global_state()\n  \n  // 创建背景\n  create_battle_background()\n  \n  // 创建UI面板\n  create_ui_panel()\n  \n  // 创建文本框\n  create_text_box()\n  \n  // 创建菜单\n  create_battle_menu()\n  \n  println(\"✅ 战斗渲染系统初始化完成\")\n}\n\n///|\n// 创建战斗背景\nfn create_battle_background() -> Unit {\n  let entity = battle_render_state.background_entity\n  \n  // 创建浅绿色网格背景\n  let background_sprite = @sprite.Sprite::from_color_rect(\n    @sprite.ColorRect::new(\n      @math.Vec2D(BATTLE_SCREEN_WIDTH, BATTLE_ARENA_HEIGHT),\n      \"#90EE90\"  // 浅绿色\n    ),\n    0  // 最底层\n  )\n  @sprite.sprites.set(entity, background_sprite)\n  @position.positions.set(entity, @math.Vec2D(0.0, 0.0))\n  \n  // 添加网格图案\n  add_grid_pattern()\n  \n  // 添加深绿色平台\n  add_battle_platforms()\n}\n\n///|\n// 添加网格图案\nfn add_grid_pattern() -> Unit {\n  // 创建网格线\n  let grid_size = 20.0\n  let mut x = 0.0\n  while x < BATTLE_SCREEN_WIDTH {\n    let grid_line = @system.Entity::new()\n    let line_sprite = @sprite.Sprite::from_color_rect(\n      @sprite.ColorRect::new(\n        @math.Vec2D(1.0, BATTLE_ARENA_HEIGHT),\n        \"#7FCC7F\"  // 稍深的绿色\n      ),\n      1\n    )\n    @sprite.sprites.set(grid_line, line_sprite)\n    @position.positions.set(grid_line, @math.Vec2D(x, 0.0))\n    x = x + grid_size\n  }\n  \n  let mut y = 0.0\n  while y < BATTLE_ARENA_HEIGHT {\n    let grid_line = @system.Entity::new()\n    let line_sprite = @sprite.Sprite::from_color_rect(\n      @sprite.ColorRect::new(\n        @math.Vec2D(BATTLE_SCREEN_WIDTH, 1.0),\n        \"#7FCC7F\"  // 稍深的绿色\n      ),\n      1\n    )\n    @sprite.sprites.set(grid_line, line_sprite)\n    @position.positions.set(grid_line, @math.Vec2D(0.0, y))\n    y = y + grid_size\n  }\n}\n\n///|\n// 添加战斗平台\nfn add_battle_platforms() -> Unit {\n  // // 玩家平台（左下角）\n  // let player_platform = @system.Entity::new()\n  // let player_platform_sprite = @sprite.Sprite::from_color_rect(\n  //   @sprite.ColorRect::new(\n  //     @math.Vec2D(PLATFORM_WIDTH, PLATFORM_HEIGHT),\n  //     \"#228B22\"  // 深绿色\n  //   ),\n  //   2\n  // )\n  // @sprite.sprites.set(player_platform, player_platform_sprite)\n  // @position.positions.set(player_platform, @math.Vec2D(50.0, BATTLE_ARENA_HEIGHT - PLATFORM_HEIGHT - 50.0))\n  \n  // // 对手平台（右上角）\n  // let enemy_platform = @system.Entity::new()\n  // let enemy_platform_sprite = @sprite.Sprite::from_color_rect(\n  //   @sprite.ColorRect::new(\n  //     @math.Vec2D(PLATFORM_WIDTH, PLATFORM_HEIGHT),\n  //     \"#228B22\"  // 深绿色\n  //   ),\n  //   2\n  // )\n  // @sprite.sprites.set(enemy_platform, enemy_platform_sprite)\n  // @position.positions.set(enemy_platform, @math.Vec2D(BATTLE_SCREEN_WIDTH - PLATFORM_WIDTH - 50.0, 50.0))\n\n//todo: currently, the enemy and player are not rendered. we need to fix this in the future.\n}\n\n///|\n// 创建UI面板\nfn create_ui_panel() -> Unit {\n  let entity = battle_render_state.ui_panel_entity\n  \n  // 创建底部UI面板\n  let panel_sprite = @sprite.Sprite::from_color_rect(\n    @sprite.ColorRect::new(\n      @math.Vec2D(BATTLE_SCREEN_WIDTH, UI_PANEL_HEIGHT),\n      \"#2E2E2E\"  // 深灰色\n    ),\n    10  // UI层\n  )\n  @sprite.sprites.set(entity, panel_sprite)\n  @position.positions.set(entity, @math.Vec2D(0.0, BATTLE_ARENA_HEIGHT))\n  \n  // 添加边框\n  add_ui_border()\n}\n\n///|\n// 添加UI边框\nfn add_ui_border() -> Unit {\n  // 顶部边框\n  let top_border = @system.Entity::new()\n  let top_border_sprite = @sprite.Sprite::from_color_rect(\n    @sprite.ColorRect::new(\n      @math.Vec2D(BATTLE_SCREEN_WIDTH, 3.0),\n      \"#FFFFFF\"  // 白色边框\n    ),\n    11\n  )\n  @sprite.sprites.set(top_border, top_border_sprite)\n  @position.positions.set(top_border, @math.Vec2D(0.0, BATTLE_ARENA_HEIGHT))\n}\n\n///|\n// 创建文本框\nfn create_text_box() -> Unit {\n  let entity = battle_render_state.text_box_entity\n  \n  // 创建深蓝色文本框背景\n  let text_bg_sprite = @sprite.Sprite::from_color_rect(\n    @sprite.ColorRect::new(\n      @math.Vec2D(400.0, 80.0),\n      \"#1E3A8A\"  // 深蓝色\n    ),\n    11  // 文本层\n  )\n  @sprite.sprites.set(entity, text_bg_sprite)\n  @position.positions.set(entity, @math.Vec2D(20.0, BATTLE_ARENA_HEIGHT + 20.0))\n  \n  // 添加文本\n  let text_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"想要火稚鸡做什么?\",\n      color=\"#FFFFFF\",\n      font=\"18px Arial\"\n    ),\n    12\n  )\n  let text_entity = battle_render_state.text_entity\n  @sprite.sprites.set(text_entity, text_sprite)\n  @position.positions.set(text_entity, @math.Vec2D(30.0, BATTLE_ARENA_HEIGHT + 35.0))\n}\n\n///|\n// 创建战斗菜单\nfn create_battle_menu() -> Unit {\n  let entity = battle_render_state.menu_entity\n  \n  // 创建浅蓝色菜单背景\n  let menu_bg_sprite = @sprite.Sprite::from_color_rect(\n    @sprite.ColorRect::new(\n      @math.Vec2D(240.0, 100.0),\n      \"#3B82F6\"  // 浅蓝色\n    ),\n    11\n  )\n  @sprite.sprites.set(entity, menu_bg_sprite)\n  @position.positions.set(entity, @math.Vec2D(BATTLE_SCREEN_WIDTH - 260.0, BATTLE_ARENA_HEIGHT + 20.0))\n  \n  // 添加菜单选项\n  create_menu_options()\n}\n\n///|\n// 创建菜单选项\nfn create_menu_options() -> Unit {\n  // 创建战斗选项\n  let battle_entity = @system.Entity::new()\n  let battle_text = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"战斗\",\n      color=\"#FFFFFF\",\n      font=\"16px Arial\"\n    ),\n    12\n  )\n  @sprite.sprites.set(battle_entity, battle_text)\n  let battle_pos = @math.Vec2D(BATTLE_SCREEN_WIDTH - 250.0, BATTLE_ARENA_HEIGHT + 35.0)\n  @position.positions.set(battle_entity, battle_pos)\n  \n  // 创建背包选项\n  let bag_entity = @system.Entity::new()\n  let bag_text = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"背包\",\n      color=\"#FFFFFF\",\n      font=\"16px Arial\"\n    ),\n    12\n  )\n  @sprite.sprites.set(bag_entity, bag_text)\n  let bag_pos = @math.Vec2D(BATTLE_SCREEN_WIDTH - 130.0, BATTLE_ARENA_HEIGHT + 35.0)\n  @position.positions.set(bag_entity, bag_pos)\n  \n  // 创建宝可梦选项\n  let pokemon_entity = @system.Entity::new()\n  let pokemon_text = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"宝可梦\",\n      color=\"#FFFFFF\",\n      font=\"16px Arial\"\n    ),\n    12\n  )\n  @sprite.sprites.set(pokemon_entity, pokemon_text)\n  let pokemon_pos = @math.Vec2D(BATTLE_SCREEN_WIDTH - 250.0, BATTLE_ARENA_HEIGHT + 70.0)\n  @position.positions.set(pokemon_entity, pokemon_pos)\n  \n  // 创建逃跑选项\n  let run_entity = @system.Entity::new()\n  let run_text = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"逃跑\",\n      color=\"#FFFFFF\",\n      font=\"16px Arial\"\n    ),\n    12\n  )\n  @sprite.sprites.set(run_entity, run_text)\n  let run_pos = @math.Vec2D(BATTLE_SCREEN_WIDTH - 130.0, BATTLE_ARENA_HEIGHT + 70.0)\n  @position.positions.set(run_entity, run_pos)\n  \n  // 创建选中指示器（黑色箭头）\n  create_menu_selector()\n}\n\n///|\n// 创建菜单选中指示器\nfn create_menu_selector() -> Unit {\n  let selector_entity = @system.Entity::new()\n  let selector_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"▶\",\n      color=\"#000000\",  // 黑色箭头\n      font=\"16px Arial\"\n    ),\n    13\n  )\n  @sprite.sprites.set(selector_entity, selector_sprite)\n  // 默认指向第一个选项（战斗）\n  @position.positions.set(selector_entity, @math.Vec2D(BATTLE_SCREEN_WIDTH - 270.0, BATTLE_ARENA_HEIGHT + 35.0))\n}\n\n///|\n// ===== 战斗输入处理功能 =====\n\n///|\n// 处理键盘输入\npub fn handle_battle_input() -> Unit {\n  // 如果技能菜单可见，处理技能菜单的输入\n  if battle_render_state.skill_menu_visible {\n    handle_skill_menu_input()\n  } else {\n    // 否则处理主菜单的输入\n    if @system.is_pressed(@system.ArrowUp) {\n      move_selection_up()\n    }\n    \n    if @system.is_pressed(@system.ArrowDown) {\n      move_selection_down()\n    }\n    \n    if @system.is_pressed(@system.ArrowLeft) {\n      move_selection_left()\n    }\n    \n    if @system.is_pressed(@system.ArrowRight) {\n      move_selection_right()\n    }\n    \n    if @system.is_pressed(@system.Enter) {\n      select_current_option()\n    }\n  }\n}\n\n///|\n// 向左移动选择 (Fight ← Bag, Pokemon ← Run)\nfn move_selection_left() -> Unit {\n  let new_option = match get_current_selection() {\n    MenuOption::Fight => MenuOption::Fight    // 左边界，不能向左\n    MenuOption::Bag => MenuOption::Fight      // Bag → Fight\n    MenuOption::Pokemon => MenuOption::Pokemon // 左边界，不能向左\n    MenuOption::Run => MenuOption::Pokemon    // Run → Pokemon\n  }\n  \n  // 更新指示器位置\n  update_indicator_position(new_option)\n  println(\"⬅️ 选择: 向左移动\")\n}\n\n///|\n// 向右移动选择 (Fight → Bag, Pokemon → Run)\nfn move_selection_right() -> Unit {\n  let new_option = match get_current_selection() {\n    MenuOption::Fight => MenuOption::Bag      // Fight → Bag\n    MenuOption::Bag => MenuOption::Bag        // 右边界，不能向右\n    MenuOption::Pokemon => MenuOption::Run    // Pokemon → Run\n    MenuOption::Run => MenuOption::Run        // 右边界，不能向右\n  }\n  \n  // 更新指示器位置\n  update_indicator_position(new_option)\n  println(\"➡️ 选择: 向右移动\")\n}\n\n///|\n// 向上移动选择 (Fight ←→ Pokemon, Bag ←→ Run)\nfn move_selection_up() -> Unit {\n  let new_option = match get_current_selection() {\n    MenuOption::Fight => MenuOption::Fight    // 上边界，不能向上\n    MenuOption::Bag => MenuOption::Bag        // 上边界，不能向上\n    MenuOption::Pokemon => MenuOption::Fight   // Pokemon → Fight\n    MenuOption::Run => MenuOption::Bag        // Run → Bag\n  }\n  \n  // 更新指示器位置\n  update_indicator_position(new_option)\n  println(\"⬆️ 选择: 向上移动\")\n}\n\n///|\n// 向下移动选择 (Fight ←→ Pokemon, Bag ←→ Run)\nfn move_selection_down() -> Unit {\n  let new_option = match get_current_selection() {\n    MenuOption::Fight => MenuOption::Pokemon  // Fight → Pokemon\n    MenuOption::Bag => MenuOption::Run         // Bag → Run\n    MenuOption::Pokemon => MenuOption::Pokemon // 下边界，不能向下\n    MenuOption::Run => MenuOption::Run         // 下边界，不能向下\n  }\n  \n  // 更新指示器位置\n  update_indicator_position(new_option)\n  println(\"⬇️ 选择: 向下移动\")\n}\n\n///|\n// 选择当前选项\nfn select_current_option() -> Unit {\n  let action = match get_current_selection() {\n    MenuOption::Fight => {\n      // 选择战斗时，打开技能菜单\n      if !battle_render_state.skill_menu_visible {\n        battle_render_state.skill_menu_visible = true\n        battle_render_state.skill_menu_selected = 0\n        show_skill_menu_ui()\n        \"选择技能\"\n      } else {\n        \"技能菜单已打开\"\n      }\n    }\n    MenuOption::Bag => \"打开背包\"\n    MenuOption::Pokemon => \"查看宝可梦\"\n    MenuOption::Run => \"尝试逃跑\"\n  }\n  println(\"✅ \" + action)\n  \n  // 更新文本框\n  update_text_box(action)\n}\n\n///|\n// 更新文本框\nfn update_text_box(text : String) -> Unit {\n  let text_entity = battle_render_state.text_entity\n  let text_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      text,\n      color=\"#FFFFFF\",\n      font=\"18px Arial\"\n    ),\n    12\n  )\n  @sprite.sprites.set(text_entity, text_sprite)\n  @position.positions.set(text_entity, @math.Vec2D(30.0, BATTLE_ARENA_HEIGHT + 35.0))\n}\n\n///|\n// ===== 战斗状态管理功能 =====\n\n///|\n// 获取宝可梦状态摘要\npub fn get_pokemon_status_summary(pokemon : Pokemon) -> String {\n  let hp_percent = (pokemon.hp.to_double() / pokemon.max_hp.to_double()) * 100.0\n  let status = if pokemon.hp <= 0 {\n    \"FAINTED\"\n  } else if hp_percent <= 25.0 {\n    \"CRITICAL\"\n  } else if hp_percent <= 50.0 {\n    \"LOW\"\n  } else if hp_percent <= 75.0 {\n    \"MODERATE\"\n  } else {\n    \"GOOD\"\n  }\n  \n  pokemon.name + \" (Lv.\" + pokemon.level.to_string() + \") - \" + \n  pokemon.hp.to_string() + \"/\" + pokemon.max_hp.to_string() + \" HP (\" + \n  hp_percent.to_string() + \"%) - \" + status\n}\n\n///|\n// 获取战斗日志\npub fn get_formatted_battle_log(battle_state : BattleState) -> String {\n  let mut formatted_log = \"\"\n  let mut turn_count = 0\n  \n  for entry in battle_state.battle_log {\n    if entry.contains(\"Turn\") && entry.contains(\"completed\") {\n      turn_count = turn_count + 1\n      formatted_log = formatted_log + \"--- Turn \" + turn_count.to_string() + \" ---\\n\"\n    } else {\n      formatted_log = formatted_log + entry + \"\\n\"\n    }\n  }\n  \n  formatted_log\n}\n\n///|\n// 检查宝可梦是否可以使用特定技能\npub fn can_use_move(pokemon : Pokemon, move_name : String) -> Bool {\n  // 检查宝可梦是否有该技能\n  let mut has_move = false\n  for move_name_check in pokemon.moves {\n    if move_name_check == move_name {\n      has_move = true\n      break\n    }\n  }\n  \n  // 检查宝可梦是否没有晕倒\n  let not_fainted = pokemon.hp > 0\n  \n  has_move && not_fainted\n}\n\n///|\n// 获取战斗统计\npub fn get_battle_statistics(battle_state : BattleState) -> String {\n  match (battle_state.player_pokemon, battle_state.enemy_pokemon) {\n    (Some(player), Some(enemy)) => {\n      let player_hp_percent = (player.hp.to_double() / player.max_hp.to_double()) * 100.0\n      let enemy_hp_percent = (enemy.hp.to_double() / enemy.max_hp.to_double()) * 100.0\n      \n      \"Battle Statistics:\\n\" +\n  \"Turn: \" + battle_state.turn.to_string() + \"\\n\" +\n      \"Player: \" + player.name + \" (HP: \" + player_hp_percent.to_string() + \"%)\\n\" +\n      \"Enemy: \" + enemy.name + \" (HP: \" + enemy_hp_percent.to_string() + \"%)\\n\" +\n  \"Log entries: \" + battle_state.battle_log.length().to_string() + \"\\n\" +\n  \"Status: \" + (if battle_state.is_active { \"Active\" } else { \"Ended\" })\n    }\n    _ => \"Battle not properly initialized\"\n  }\n}\n\n///|\n// 计算伤害\npub fn calculate_damage(attacker : Pokemon, defender : Pokemon, skill : Move) -> Int {\n  // 使用技能威力作为基础伤害\n  let base_damage = skill.power\n  let level_factor = attacker.level\n  let attack_defense_ratio = attacker.attack / defender.defense\n  \n  // 计算基础伤害\n  let base_calc = base_damage * level_factor * attack_defense_ratio / 100\n  \n  // 应用类型克制\n  let final_damage = apply_move_effect_simple(base_calc, skill.element_type)\n  \n  // 放大10倍伤害\n  let amplified_damage = final_damage * 10\n  \n  if amplified_damage < 1 { 1 } else { amplified_damage }\n}\n\n///|\n// 应用技能效果（简化版本）\npub fn apply_move_effect_simple(base_damage : Int, move_type : String) -> Int {\n  // 简化的伤害计算，只考虑基础伤害和类型\n  let type_multiplier = match move_type {\n    \"Fire\" => 1.5\n    \"Water\" => 1.3\n    \"Electric\" => 1.4\n    \"Grass\" => 1.2\n    \"Ice\" => 1.3\n    \"Fighting\" => 1.4\n    \"Poison\" => 1.2\n    \"Ground\" => 1.3\n    \"Flying\" => 1.3\n    \"Psychic\" => 1.4\n    \"Bug\" => 1.1\n    \"Rock\" => 1.3\n    \"Ghost\" => 1.4\n    \"Dragon\" => 1.5\n    \"Dark\" => 1.3\n    \"Steel\" => 1.2\n    \"Fairy\" => 1.3\n    _ => 1.0\n  }\n  \n  (base_damage.to_double() * type_multiplier).to_int()\n}\n\n\n\n///|\n// 状态转字符串\npub fn status_to_string(status_name : String) -> String {\n  match status_name {\n    \"normal\" => \"正常\"\n    \"poison\" => \"中毒\"\n    \"burn\" => \"灼烧\"\n    \"freeze\" => \"冰冻\"\n    \"paralysis\" => \"麻痹\"\n    \"sleep\" => \"睡眠\"\n    \"fainted\" => \"濒死\"\n    _ => \"未知状态\"\n  }\n}\n\n///|\n// 效果类型转字符串\npub fn effect_type_to_string(effect_type : String) -> String {\n  match effect_type {\n    \"Ability\" => \"特性\"\n    \"Item\" => \"道具\"\n    \"Move\" => \"技能\"\n    \"Status\" => \"状态\"\n    \"Weather\" => \"天气\"\n    \"Terrain\" => \"场地\"\n    \"Field\" => \"场地效果\"\n    _ => \"未知效果\"\n  }\n}\n\n///|\n// 伤害类型转字符串\npub fn damage_type_to_string(damage_type : String) -> String {\n  match damage_type {\n    \"Physical\" => \"物理\"\n    \"Special\" => \"特殊\"\n    \"Status\" => \"变化\"\n    \"True\" => \"真实\"\n    _ => \"未知类型\"\n  }\n}\n\n///|\n// 使用技能\npub fn use_move(move_name : String, is_player : Bool, battle_state : BattleState) -> String {\n  match (battle_state.player_pokemon, battle_state.enemy_pokemon) {\n    (Some(player), Some(enemy)) => {\n      let attacker = if is_player { player } else { enemy }\n      let defender = if is_player { enemy } else { player }\n  \n  let move_obj = create_move_from_name(move_name)\n  let damage = calculate_damage(attacker, defender, move_obj)\n  attacker.name + \" used \" + move_name + \"! It dealt \" + damage.to_string() + \" damage!\"\n    }\n    _ => \"Battle not properly initialized\"\n  }\n}\n\n///|\n// 开始战斗\npub fn start_battle(player_pokemon : Pokemon, enemy_pokemon : Pokemon) -> String {\n  \"Battle started! \" + player_pokemon.name + \" VS \" + enemy_pokemon.name\n}\n\n///|\n// 重置战斗\npub fn reset_battle() -> Unit {\n  println(\"Battle has been reset\")\n}\n\n///|\n// 创建战斗状态\npub fn create_battle_state(player_pokemon : Pokemon, enemy_pokemon : Pokemon) -> BattleState {\n  BattleState::{\n    is_active: true,\n    turn: 1,\n    current_turn_type: TurnType::PlayerTurn,\n    player_pokemon: Some(player_pokemon),\n    enemy_pokemon: Some(enemy_pokemon),\n    battle_log: [],\n    actions_this_turn: 0,\n    max_actions_per_turn: 1\n  }\n}\n\n///|\n// 更新战斗状态\npub fn update_battle_state_after_move(\n  battle_state : BattleState, \n  move_name : String, \n  _is_player : Bool, \n  damage : Int, \n  _hit : Bool\n) -> BattleState {\n  let new_log = battle_state.battle_log + [move_name + \" dealt \" + damage.to_string() + \" damage\"]\n  \n  BattleState::{\n    is_active: battle_state.is_active,\n    turn: battle_state.turn,\n    current_turn_type: battle_state.current_turn_type,\n    player_pokemon: battle_state.player_pokemon,\n    enemy_pokemon: battle_state.enemy_pokemon,\n    battle_log: new_log,\n    actions_this_turn: battle_state.actions_this_turn,\n    max_actions_per_turn: battle_state.max_actions_per_turn\n  }\n}\n\n///|\n// 结束回合\npub fn end_turn(battle_state : BattleState) -> BattleState {\n  BattleState::{\n    is_active: battle_state.is_active,\n    turn: battle_state.turn + 1,\n    current_turn_type: battle_state.current_turn_type,\n    player_pokemon: battle_state.player_pokemon,\n    enemy_pokemon: battle_state.enemy_pokemon,\n    battle_log: battle_state.battle_log,\n    actions_this_turn: 0,\n    max_actions_per_turn: battle_state.max_actions_per_turn\n  }\n}\n\n///|\n// 重置战斗状态\npub fn reset_battle_state(battle_state : BattleState) -> BattleState {\n  BattleState::{\n    is_active: true,\n    turn: 1,\n    current_turn_type: TurnType::PlayerTurn,\n    player_pokemon: battle_state.player_pokemon,\n    enemy_pokemon: battle_state.enemy_pokemon,\n    battle_log: [],\n    actions_this_turn: 0,\n    max_actions_per_turn: 1\n  }\n}\n\n///|\n// 获取战斗状态\npub fn get_battle_status(battle_state : BattleState) -> String {\n  \"Battle Status: Turn \" + battle_state.turn.to_string() + \", Active: \" + battle_state.is_active.to_string()\n}\n\n///|\n// 检查战斗是否结束\npub fn is_battle_finished(battle_state : BattleState) -> Bool {\n  match (battle_state.player_pokemon, battle_state.enemy_pokemon) {\n    (Some(player), Some(enemy)) => player.hp <= 0 || enemy.hp <= 0\n    _ => false\n  }\n}\n\n///|\n// 获取获胜者\npub fn get_winner(battle_state : BattleState) -> String {\n  match (battle_state.player_pokemon, battle_state.enemy_pokemon) {\n    (Some(player), Some(enemy)) => {\n      if player.hp <= 0 {\n    \"Enemy wins!\"\n      } else if enemy.hp <= 0 {\n    \"Player wins!\"\n  } else {\n    \"Battle still in progress\"\n      }\n    }\n    _ => \"Battle not properly initialized\"\n  }\n}\n\n///|\n// 获取可用技能\npub fn get_available_moves(pokemon : Pokemon) -> Array[String] {\n  pokemon.moves\n}\n\n///|\n// 更新宝可梦HP\npub fn update_pokemon_hp(pokemon : Pokemon, new_hp : Int) -> Pokemon {\n  let clamped_hp = if new_hp < 0 { 0 } else if new_hp > pokemon.max_hp { pokemon.max_hp } else { new_hp }\n  \n  Pokemon::{\n    id: pokemon.id,\n    name: pokemon.name,\n    level: pokemon.level,\n    hp: clamped_hp,\n    max_hp: pokemon.max_hp,\n    attack: pokemon.attack,\n    defense: pokemon.defense,\n    speed: pokemon.speed,\n    types: pokemon.types,\n    moves: pokemon.moves\n  }\n}\n\n///|\n// ===== 战斗场景功能 =====\n\n\n///|\n// 开始战斗渲染（移除血条初始化，只保留宝可梦渲染）\npub fn start_battle_render(player_pokemon : Pokemon, enemy_pokemon : Pokemon) -> Unit {\n  println(\"🎮 开始战斗渲染...\")\n  \n  // 设置当前宝可梦数据\n  battle_render_state.current_player_pokemon = Some(player_pokemon)\n  battle_render_state.current_enemy_pokemon = Some(enemy_pokemon)\n  \n  // 初始化战斗状态\n  let initial_battle_state = BattleState::{\n    is_active: true,\n    turn: 1,\n    current_turn_type: TurnType::PlayerTurn,\n    player_pokemon: Some(player_pokemon),\n    enemy_pokemon: Some(enemy_pokemon),\n    battle_log: [],\n    actions_this_turn: 0,\n    max_actions_per_turn: 1\n  }\n  battle_render_state.battle_state = Some(initial_battle_state)\n  \n  // 初始化回合显示\n  if turn_display_state.turn_display.is_none() {\n    init_turn_display_system()\n  }\n  update_turn_display(1, \"PlayerTurn\")\n  \n  // 渲染宝可梦\n  render_pokemon(player_pokemon, enemy_pokemon)\n  \n  println(\"✅ 战斗渲染开始，战斗状态已初始化\")\n}\n\n///|\n// 渲染宝可梦\nfn render_pokemon(player_pokemon : Pokemon, enemy_pokemon : Pokemon) -> Unit {\n  // 只渲染宝可梦精灵，不重新创建血条\n  render_player_pokemon(player_pokemon)\n  render_enemy_pokemon(enemy_pokemon)\n  \n  // 只更新现有血条，不重新创建\n  update_pokemon_status_display(player_pokemon, false)\n  update_pokemon_status_display(enemy_pokemon, true)\n}\n\n///|\nfn render_player_pokemon(_pokemon : Pokemon) -> Unit {\n  let entity = battle_render_state.player_pokemon_entity\n  \n  println(\"🎨 正在渲染玩家宝可梦，使用完整图片尺寸\")\n  \n  // 使用图片的完整尺寸 832×1248\n  let pokemon_sprite = @sprite.Sprite::from_picture(\n    @sprite.Picture::new(\n      @math.Vec2D(64.0, 64.0),  // 使用64x64尺寸\n      \"pic/moonrabbit_back64.png\",  // 修复路径，去掉开头的点\n      transform=@math.Transform::new(),\n      repeat=@system.RepeatMode::NoRepeat\n    ),\n    15\n  )\n  \n  @sprite.sprites.set(entity, pokemon_sprite)\n  @position.positions.set(entity, @math.Vec2D(70.0, BATTLE_ARENA_HEIGHT - 64.0 - 70.0))  // 调整位置\n  \n  println(\"✅ 玩家宝可梦精灵已设置（完整尺寸）\")\n}\n\nfn render_enemy_pokemon(_pokemon : Pokemon) -> Unit {\n  let entity = battle_render_state.enemy_pokemon_entity\n  \n  println(\"🎨 正在渲染敌方宝可梦（使用颜色方块测试）\")\n  \n  let pokemon_sprite = @sprite.Sprite::from_picture(\n    @sprite.Picture::new(\n      @math.Vec2D(64.0, 64.0),  // 使用64x64尺寸\n      \"pic/moonrabbit_back64.png\",  // 修复路径，去掉开头的点\n      transform=@math.Transform::new(),\n      repeat=@system.RepeatMode::NoRepeat\n    ),\n    15\n  )\n  \n  @sprite.sprites.set(entity, pokemon_sprite)\n  @position.positions.set(entity, @math.Vec2D(BATTLE_SCREEN_WIDTH - 64.0 - 70.0, 70.0))  // 调整位置\n  \n  println(\"✅ 敌方宝可梦精灵已设置\")\n}\n\n///|\n// 渲染宝可梦状态（使用统一的宝可梦信息显示模版）\nfn render_pokemon_status(pokemon : Pokemon, position : @math.Vec2D, is_enemy : Bool) -> Unit {\n  // 创建宝可梦信息显示配置\n  let config = if is_enemy {\n    {\n      base_position: position,\n      width: 200.0,\n      height: 20.0,\n      background_color: \"#333333\",\n      fill_color: \"#FF0000\",  // 红色\n      text_color: \"#FFFFFF\",\n      bar_type: HealthBarType::Enemy\n    }\n  } else {\n    {\n      base_position: position,\n      width: 200.0,\n      height: 20.0,\n      background_color: \"#333333\",\n      fill_color: \"#00FF00\",  // 绿色\n      text_color: \"#FFFFFF\",\n      bar_type: HealthBarType::Player\n    }\n  }\n  \n  // 创建宝可梦信息显示模版\n  let pokemon_info = create_pokemon_info_template(config, pokemon.name, pokemon.level, pokemon.max_hp)\n  \n  // 更新全局状态\n  if is_enemy {\n    battle_render_state.enemy_pokemon_info = Some(pokemon_info)\n  } else {\n    battle_render_state.player_pokemon_info = Some(pokemon_info)\n  }\n  \n  println(\" 宝可梦状态渲染完成: \" + pokemon.name + \" Lv.\" + pokemon.level.to_string())\n}\n\n///|\n// 更新宝可梦状态显示\nfn update_pokemon_status_display(pokemon : Pokemon, is_enemy : Bool) -> Unit {\n  let pokemon_info_opt = if is_enemy {\n    battle_render_state.enemy_pokemon_info\n  } else {\n    battle_render_state.player_pokemon_info\n  }\n  \n  match pokemon_info_opt {\n    Some(pokemon_info) => {\n      // 只更新现有血条，不重新创建\n      update_pokemon_info_display(pokemon_info, pokemon.name, pokemon.level, pokemon.hp, pokemon.max_hp)\n    }\n    None => {\n      // 只有在血条不存在时才创建\n      let position = if is_enemy { @math.Vec2D(350.0, 50.0) } else { @math.Vec2D(450.0, 350.0) }\n      render_pokemon_status(pokemon, position, is_enemy)\n    }\n  }\n}\n\n///|\n// 进入技能UI模式\nfn enter_skill_ui_mode() -> Unit {\n  println(\"🎯 进入技能UI模式\")\n  \n  // 从当前宝可梦获取技能列表\n  let current_moves = get_current_player_moves()\n  \n  // 获取当前选中的技能\n  if battle_render_state.skill_menu_selected >= 0 && battle_render_state.skill_menu_selected < current_moves.length() {\n    let selected_skill = current_moves[battle_render_state.skill_menu_selected]\n    println(\"⚔️ 准备使用技能: \" + selected_skill.name)\n    \n    // 显示技能UI界面\n    show_skill_ui_interface(selected_skill)\n    \n    // 执行技能 - 玩家攻击\n    execute_battle_skill(selected_skill, true)\n  } else {\n    println(\"❌ 无效的技能选择\")\n  }\n}\n\n///|\n// 切换技能菜单\nfn toggle_skill_menu() -> Unit {\n  println(\"🔄 切换技能菜单\")\n  \n  if battle_render_state.skill_menu_visible {\n    // 如果技能菜单已经可见，隐藏它\n    battle_render_state.skill_menu_visible = false\n    hide_skill_menu_ui()\n  } else {\n    // 如果技能菜单不可见，显示它\n    battle_render_state.skill_menu_visible = true\n  battle_render_state.skill_menu_selected = 0\n    show_skill_menu_ui()\n  }\n}\n\n///|\n// 全局技能菜单实体管理 - 使用结构体来管理所有实体\npub struct SkillMenuEntities {\n  background_entity: @system.Entity\n  title_entity: @system.Entity\n  skill_entities: Array[@system.Entity]\n  selector_entity: @system.Entity\n}\n\n///|\n// 全局技能菜单实体 - 移除mut，使用结构体包装\npub struct SkillMenuState {\n  mut entities: Option[SkillMenuEntities]\n}\n\nlet skill_menu_state: SkillMenuState = {\n  entities: None\n}\n\n///|\n// 全局技能选择指示器实体\nlet skill_selector_entity : @system.Entity = @system.Entity::new()\n\n///|\n// 显示技能菜单UI\nfn show_skill_menu_ui() -> Unit {\n  println(\"🎯 显示技能菜单UI\")\n  \n  // 先清理之前的技能菜单实体\n  clear_skill_menu_entities()\n  \n  // 获取当前玩家宝可梦的技能\n  let current_moves = get_current_player_moves()\n  \n  if current_moves.length() > 0 {\n    // 创建技能菜单背景\n    let menu_bg_entity = @system.Entity::new()\n    let menu_bg_sprite = @sprite.Sprite::from_color_rect(\n      @sprite.ColorRect::new(\n        @math.Vec2D(300.0, 200.0),\n        \"#2C3E50\"\n      ),\n      14\n    )\n    @sprite.sprites.set(menu_bg_entity, menu_bg_sprite)\n    @position.positions.set(menu_bg_entity, @math.Vec2D(250.0, 200.0))\n    \n    // 创建技能列表标题\n    let title_entity = @system.Entity::new()\n    let title_sprite = @sprite.Sprite::from_text(\n      @sprite.Text::new(\n        \"选择技能\",\n        color=\"#FFFFFF\",\n        font=\"18px Arial\"\n      ),\n      15\n    )\n    @sprite.sprites.set(title_entity, title_sprite)\n    @position.positions.set(title_entity, @math.Vec2D(270.0, 220.0))\n    \n    // 创建技能选择指示器\n    let selector_entity = @system.Entity::new()\n    let selector_sprite = @sprite.Sprite::from_text(\n      @sprite.Text::new(\n        \"▶\",\n        color=\"#F39C12\",\n        font=\"16px Arial\"\n      ),\n      16\n    )\n    @sprite.sprites.set(selector_entity, selector_sprite)\n    @position.positions.set(selector_entity, @math.Vec2D(270.0, 250.0))\n    \n    // 创建技能列表实体\n    let skill_entities = create_skill_list_entities(current_moves)\n    \n    // 保存所有实体\n    skill_menu_state.entities = Some(SkillMenuEntities::{\n      background_entity: menu_bg_entity,\n      title_entity: title_entity,\n      skill_entities: skill_entities,\n      selector_entity: selector_entity\n    })\n  } else {\n    println(\"❌ 当前宝可梦没有技能\")\n  }\n}\n\n///|\n// 创建技能列表实体\nfn create_skill_list_entities(moves: Array[Move]) -> Array[@system.Entity] {\n  let skill_entities: Array[@system.Entity] = []\n  \n  for i = 0; i < moves.length(); i = i + 1 {\n    let move = moves[i]\n    let skill_entity = @system.Entity::new()\n    let skill_sprite = @sprite.Sprite::from_text(\n      @sprite.Text::new(\n        move.name + \" (PP: \" + move.pp.to_string() + \"/\" + move.max_pp.to_string() + \")\",\n        color=\"#FFFFFF\",\n        font=\"14px Arial\"\n      ),\n      17 + i\n    )\n    @sprite.sprites.set(skill_entity, skill_sprite)\n    @position.positions.set(skill_entity, @math.Vec2D(290.0, 250.0 + i.to_double() * 25.0))\n    skill_entities.push(skill_entity)\n  }\n  \n  skill_entities\n}\n\n///|\n// 清理技能菜单实体\nfn clear_skill_menu_entities() -> Unit {\n  match skill_menu_state.entities {\n    Some(entities) => {\n      // 清理背景\n      @sprite.sprites.remove(entities.background_entity)\n      @position.positions.remove(entities.background_entity)\n      \n      // 清理标题\n      @sprite.sprites.remove(entities.title_entity)\n      @position.positions.remove(entities.title_entity)\n      \n      // 清理所有技能实体\n      for skill_entity in entities.skill_entities {\n        @sprite.sprites.remove(skill_entity)\n        @position.positions.remove(skill_entity)\n      }\n      \n      // 清理选择指示器\n      @sprite.sprites.remove(entities.selector_entity)\n      @position.positions.remove(entities.selector_entity)\n      \n      // 清空实体\n      skill_menu_state.entities = None\n    }\n    None => {\n      // 清理旧的技能选择指示器\n      @sprite.sprites.remove(skill_selector_entity)\n      @position.positions.remove(skill_selector_entity)\n    }\n  }\n  \n  println(\"🧹 技能菜单实体清理完成\")\n}\n\n///|\n// 创建技能选择指示器\nfn create_skill_selector() -> Unit {\n  let selector_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"▶\",\n      color=\"#F39C12\",\n      font=\"16px Arial\"\n    ),\n    16\n  )\n  @sprite.sprites.set(skill_selector_entity, selector_sprite)\n  // 默认指向第一个技能\n  @position.positions.set(skill_selector_entity, @math.Vec2D(270.0, 250.0))\n}\n\n///|\n// 显示技能列表\nfn show_skill_list(moves: Array[Move]) -> Unit {\n  println(\"🎯 显示技能列表，共 \" + moves.length().to_string() + \" 个技能\")\n  \n  for i = 0; i < moves.length(); i = i + 1 {\n    let move = moves[i]\n    let skill_entity = @system.Entity::new()\n    let skill_sprite = @sprite.Sprite::from_text(\n      @sprite.Text::new(\n        move.name + \" (PP: \" + move.pp.to_string() + \"/\" + move.max_pp.to_string() + \")\",\n        color=\"#FFFFFF\",\n        font=\"14px Arial\"\n      ),\n      17 + i\n    )\n    @sprite.sprites.set(skill_entity, skill_sprite)\n    @position.positions.set(skill_entity, @math.Vec2D(290.0, 250.0 + i.to_double() * 25.0))\n  }\n}\n\n///|\n// 处理技能菜单输入\nfn handle_skill_menu_input() -> Unit {\n  // 处理上下箭头键选择技能\n  if @system.is_pressed(@system.ArrowUp) {\n    move_skill_selection_up()\n  }\n  \n  if @system.is_pressed(@system.ArrowDown) {\n    move_skill_selection_down()\n  }\n  \n  // 处理确认选择 - Z键选择技能\n  if @system.is_pressed(@system.KeyZ) {\n    select_current_skill()\n  }\n  \n  // 处理取消选择 - X键返回主菜单\n  if @system.is_pressed(@system.KeyX) {\n    cancel_skill_selection()\n  }\n}\n\n///|\n// 向上移动技能选择\nfn move_skill_selection_up() -> Unit {\n  let current_moves = get_current_player_moves()\n  if current_moves.length() > 0 {\n    battle_render_state.skill_menu_selected = if battle_render_state.skill_menu_selected > 0 {\n      battle_render_state.skill_menu_selected - 1\n    } else {\n      current_moves.length() - 1\n    }\n    update_skill_selector_position()\n    println(\"⬆️ 选择技能: \" + current_moves[battle_render_state.skill_menu_selected].name)\n  }\n}\n\n///|\n// 向下移动技能选择\nfn move_skill_selection_down() -> Unit {\n  let current_moves = get_current_player_moves()\n  if current_moves.length() > 0 {\n    battle_render_state.skill_menu_selected = if battle_render_state.skill_menu_selected < current_moves.length() - 1 {\n      battle_render_state.skill_menu_selected + 1\n    } else {\n      0\n    }\n    update_skill_selector_position()\n    println(\"⬇️ 选择技能: \" + current_moves[battle_render_state.skill_menu_selected].name)\n  }\n}\n\n///|\n// 更新技能选择指示器位置\nfn update_skill_selector_position() -> Unit {\n  match skill_menu_state.entities {\n    Some(entities) => {\n      // 计算指示器位置\n      let y_position = 250.0 + battle_render_state.skill_menu_selected.to_double() * 25.0\n      \n      // 更新选择指示器位置\n      @position.positions.set(entities.selector_entity, @math.Vec2D(270.0, y_position))\n      println(\"🎯 更新技能选择指示器位置: \" + y_position.to_string())\n    }\n    None => {\n      println(\"❌ 技能菜单实体未创建\")\n    }\n  }\n}\n\n///|\n// 选择当前技能\nfn select_current_skill() -> Unit {\n  let current_moves = get_current_player_moves()\n  if battle_render_state.skill_menu_selected >= 0 && battle_render_state.skill_menu_selected < current_moves.length() {\n    let selected_skill = current_moves[battle_render_state.skill_menu_selected]\n    println(\"✅ 选择了技能: \" + selected_skill.name)\n    \n    // 隐藏技能菜单\n    battle_render_state.skill_menu_visible = false\n    hide_skill_menu_ui()\n    \n    // 执行技能\n    execute_battle_skill(selected_skill, true)\n  } else {\n    println(\"❌ 无效的技能选择\")\n  }\n}\n\n///|\n// 取消技能选择\nfn cancel_skill_selection() -> Unit {\n  println(\"❌ 取消技能选择\")\n  battle_render_state.skill_menu_visible = false\n  battle_render_state.skill_menu_selected = 0\n  hide_skill_menu_ui()\n}\n\n// 添加缺少的变量和函数\nlet battle_skills : Array[Move] = []\n\n///|\n// 将技能名称转换为Move结构体\nfn create_move_from_name(move_name: String) -> Move {\n  // 根据技能名称创建对应的Move结构体\n  match move_name {\n    \"Tackle\" => Move::{\n      name: \"Tackle\",\n      power: 40,\n      accuracy: 100,\n      move_type: MoveType::Physical,\n      element_type: \"Normal\",\n      pp: 35,\n      max_pp: 35\n    }\n    \"Ember\" => Move::{\n      name: \"Ember\",\n      power: 40,\n      accuracy: 100,\n      move_type: MoveType::Special,\n      element_type: \"Fire\",\n      pp: 25,\n      max_pp: 25\n    }\n    \"Thunder\" => Move::{\n      name: \"Thunder\",\n      power: 110,\n      accuracy: 70,\n      move_type: MoveType::Special,\n      element_type: \"Electric\",\n      pp: 10,\n      max_pp: 10\n    }\n    \"Hyper Beam\" => Move::{\n      name: \"Hyper Beam\",\n      power: 150,\n      accuracy: 90,\n      move_type: MoveType::Special,\n      element_type: \"Normal\",\n      pp: 5,\n      max_pp: 5\n    }\n    _ => Move::{\n      name: move_name,\n      power: 50,\n      accuracy: 100,\n      move_type: MoveType::Physical,\n      element_type: \"Normal\",\n      pp: 20,\n      max_pp: 20\n    }\n  }\n}\n\n///|\n// 从宝可梦获取技能列表\nfn get_pokemon_moves(pokemon: Pokemon) -> Array[Move] {\n  let moves: Array[Move] = []\n  for move_name in pokemon.moves {\n    moves.push(create_move_from_name(move_name))\n  }\n  moves\n}\n\n///|\n// 获取当前玩家宝可梦的技能\nfn get_current_player_moves() -> Array[Move] {\n  match battle_render_state.current_player_pokemon {\n    Some(pokemon) => get_pokemon_moves(pokemon)\n    None => []\n  }\n}\n\n///|\n// 显示技能UI界面\nfn show_skill_ui_interface(skill: Move) -> Unit {\n  println(\"🎨 显示技能UI界面: \" + skill.name)\n  \n  // 创建技能使用动画 - 显示在屏幕顶部中央，避免与菜单重叠\n  let skill_animation_entity = @system.Entity::new()\n  let animation_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \" \" + skill.name + \" \",\n      color=\"#FF6B6B\",\n      font=\"20px Arial\"\n    ),\n    16\n  )\n  @sprite.sprites.set(skill_animation_entity, animation_sprite)\n  @position.positions.set(skill_animation_entity, @math.Vec2D(400.0, 100.0))\n  \n  // 创建技能效果文本 - 显示在技能名称下方\n  let effect_entity = @system.Entity::new()\n  let effect_sprite = @sprite.Sprite::from_text(\n    @sprite.Text::new(\n      \"效果: \" + skill.name,\n      color=\"#FFFFFF\",\n      font=\"14px Arial\"\n    ),\n    16\n  )\n  @sprite.sprites.set(effect_entity, effect_sprite)\n  @position.positions.set(effect_entity, @math.Vec2D(400.0, 130.0))\n}\n\n///|\n// 执行战斗技能\nfn execute_battle_skill(skill: Move, is_player_attacking: Bool) -> Unit {\n  println(\"⚔️ 执行技能: \" + skill.name)\n  \n  // 获取当前战斗中的宝可梦\n  match battle_render_state.current_player_pokemon {\n    Some(player_pokemon) => {\n      match battle_render_state.current_enemy_pokemon {\n        Some(enemy_pokemon) => {\n          // 根据攻击者确定攻击者和防御者\n          let (attacker, defender) = if is_player_attacking {\n            (player_pokemon, enemy_pokemon)\n          } else {\n            (enemy_pokemon, player_pokemon)\n          }\n          \n          // 计算伤害\n          let damage = calculate_damage(attacker, defender, skill)\n          \n          // 更新被攻击方的HP\n          let new_defender_hp = if defender.hp > damage { \n            defender.hp - damage \n          } else { \n            0 \n          }\n          \n          let updated_defender = update_pokemon_hp(defender, new_defender_hp)\n          \n          // 根据攻击者更新对应的全局状态\n          if is_player_attacking {\n            // 玩家攻击，更新敌方宝可梦\n            battle_render_state.current_enemy_pokemon = Some(updated_defender)\n            // 同步更新战斗状态中的敌方宝可梦\n            match battle_render_state.battle_state {\n              Some(state) => {\n                let updated_battle_state = BattleState::{\n                  is_active: state.is_active,\n                  turn: state.turn,\n                  current_turn_type: state.current_turn_type,\n                  player_pokemon: state.player_pokemon,\n                  enemy_pokemon: Some(updated_defender), // 更新敌方宝可梦\n                  battle_log: state.battle_log,\n                  actions_this_turn: state.actions_this_turn,\n                  max_actions_per_turn: state.max_actions_per_turn\n                }\n                battle_render_state.battle_state = Some(updated_battle_state)\n              }\n              None => ()\n            }\n            // 更新敌方血条 - 使用新的统一更新函数\n            match battle_render_state.enemy_pokemon_info {\n              Some(pokemon_info) => {\n                update_pokemon_info_display(pokemon_info, updated_defender.name, updated_defender.level, updated_defender.hp, updated_defender.max_hp)\n              }\n              None => {\n                println(\"❌ 敌方宝可梦信息显示未创建\")\n              }\n            }\n          } else {\n            // 敌方攻击，更新玩家宝可梦\n            battle_render_state.current_player_pokemon = Some(updated_defender)\n            // 同步更新战斗状态中的玩家宝可梦\n            match battle_render_state.battle_state {\n              Some(state) => {\n                let updated_battle_state = BattleState::{\n                  is_active: state.is_active,\n                  turn: state.turn,\n                  current_turn_type: state.current_turn_type,\n                  player_pokemon: Some(updated_defender), // 更新玩家宝可梦\n                  enemy_pokemon: state.enemy_pokemon,\n                  battle_log: state.battle_log,\n                  actions_this_turn: state.actions_this_turn,\n                  max_actions_per_turn: state.max_actions_per_turn\n                }\n                battle_render_state.battle_state = Some(updated_battle_state)\n              }\n              None => ()\n            }\n            // 更新玩家血条 - 使用新的统一更新函数\n            match battle_render_state.player_pokemon_info {\n              Some(pokemon_info) => {\n                update_pokemon_info_display(pokemon_info, updated_defender.name, updated_defender.level, updated_defender.hp, updated_defender.max_hp)\n              }\n              None => {\n                println(\"❌ 玩家宝可梦信息显示未创建\")\n              }\n            }\n          }\n          \n          // 显示伤害信息\n          let damage_message = attacker.name + \" 使用了 \" + skill.name + \"! 对 \" + \n                              defender.name + \" 造成了 \" + damage.to_string() + \" 点伤害!\"\n          println(\" \" + damage_message)\n          \n          // 更新文本框显示伤害信息\n          update_text_box(damage_message)\n          \n          // 检查被攻击方是否被击败\n          if new_defender_hp <= 0 {\n            let victory_message = defender.name + \" 被击败了! \" + attacker.name + \" 获胜!\"\n            println(\"🎉 \" + victory_message)\n            update_text_box(victory_message)\n          }\n          \n          // 重新渲染宝可梦状态\n          let (updated_player, updated_enemy) = if is_player_attacking {\n            (player_pokemon, updated_defender)\n          } else {\n            (updated_defender, enemy_pokemon)\n          }\n          \n          render_pokemon(updated_player, updated_enemy)\n          \n          // 增加行动次数\n          increment_actions_this_turn()\n          \n          // 添加：玩家攻击后结束回合，触发敌人回合\n          if is_player_attacking {\n            end_current_turn()\n          }\n        }\n        None => {\n          println(\"❌ 没有找到敌方宝可梦\")\n        }\n      }\n    }\n    None => {\n      println(\"❌ 没有找到玩家宝可梦\")\n    }\n  }\n}\n\n///|\n// 增加当前回合的行动次数\nfn increment_actions_this_turn() -> Unit {\n  match battle_render_state.battle_state {\n    Some(state) => {\n      let new_actions = state.actions_this_turn + 1\n      let updated_state = BattleState::{\n        is_active: state.is_active,\n        turn: state.turn,\n        current_turn_type: state.current_turn_type,\n        player_pokemon: state.player_pokemon,\n        enemy_pokemon: state.enemy_pokemon,\n        battle_log: state.battle_log,\n        actions_this_turn: new_actions,\n        max_actions_per_turn: state.max_actions_per_turn\n      }\n      battle_render_state.battle_state = Some(updated_state)\n      println(\"📊 行动次数: \" + new_actions.to_string() + \"/\" + state.max_actions_per_turn.to_string())\n    }\n    None => {\n      println(\"❌ 战斗状态未初始化\")\n    }\n  }\n}\n\n///|\n// 回合类型枚举\npub enum TurnType {\n  PlayerTurn\n  EnemyTurn\n} derive(Show, Eq)\n\n///|\n// 战斗状态（增强版）\npub struct BattleState {\n  is_active: Bool\n  turn: Int\n  current_turn_type: TurnType\n  player_pokemon: Option[Pokemon]\n  enemy_pokemon: Option[Pokemon]\n  battle_log: Array[String]\n  actions_this_turn: Int\n  max_actions_per_turn: Int\n} derive(Show)\n\n///|\n// 开始新回合\npub fn start_new_turn() -> Unit {\n  match battle_render_state.battle_state {\n    Some(state) => {\n      let new_turn = state.turn + 1\n      let new_turn_type = if state.current_turn_type == TurnType::PlayerTurn {\n        TurnType::EnemyTurn\n      } else {\n        TurnType::PlayerTurn\n      }\n      \n      let updated_state = BattleState::{\n        is_active: state.is_active,\n        turn: new_turn,\n        current_turn_type: new_turn_type,\n        player_pokemon: state.player_pokemon,\n        enemy_pokemon: state.enemy_pokemon,\n        battle_log: state.battle_log,\n        actions_this_turn: 0,\n        max_actions_per_turn: state.max_actions_per_turn\n      }\n      \n      battle_render_state.battle_state = Some(updated_state)\n      \n      let turn_name = match new_turn_type {\n        TurnType::PlayerTurn => \"玩家\"\n        TurnType::EnemyTurn => \"敌人\"\n      }\n      \n      let turn_type_string = match new_turn_type {\n        TurnType::PlayerTurn => \"PlayerTurn\"\n        TurnType::EnemyTurn => \"EnemyTurn\"\n      }\n      \n      println(\"🔄 开始第 \" + new_turn.to_string() + \" 回合 - \" + turn_name + \" 的回合\")\n      update_text_box(\"第 \" + new_turn.to_string() + \" 回合 - \" + turn_name + \" 的回合\")\n      \n      // 更新回合显示\n      update_turn_display(new_turn, turn_type_string)\n    }\n    None => {\n      println(\"❌ 战斗状态未初始化\")\n    }\n  }\n}\n\n///|\n// 检查是否可以行动\npub fn can_act() -> Bool {\n  match battle_render_state.battle_state {\n    Some(state) => {\n      state.actions_this_turn < state.max_actions_per_turn\n    }\n    None => false\n  }\n}\n\n///|\n// 检查是否是玩家回合\npub fn is_player_turn() -> Bool {\n  match battle_render_state.battle_state {\n    Some(state) => {\n      state.current_turn_type == TurnType::PlayerTurn\n    }\n    None => false\n  }\n}\n\n///|\n// 检查是否是敌人回合\npub fn is_enemy_turn() -> Bool {\n  match battle_render_state.battle_state {\n    Some(state) => {\n      state.current_turn_type == TurnType::EnemyTurn\n    }\n    None => false\n  }\n}\n\n///|\n// 执行行动（增加回合检查）\npub fn execute_action() -> Unit {\n  if !can_act() {\n    println(\"❌ 本回合已无法行动\")\n    return\n  }\n  \n  if is_player_turn() {\n    println(\" 玩家回合 - 等待玩家选择技能\")\n    // 玩家回合逻辑\n  } else if is_enemy_turn() {\n    println(\"🤖 敌人回合 - 自动选择技能\")\n    // 敌人回合逻辑\n    execute_enemy_turn()\n  }\n}\n\n///|\n// 执行敌人回合\nfn execute_enemy_turn() -> Unit {\n  match battle_render_state.current_enemy_pokemon {\n    Some(enemy_pokemon) => {\n      // 敌人随机选择一个技能\n      let moves = get_pokemon_moves(enemy_pokemon)\n      if moves.length() > 0 {\n        // 创建随机数生成器并生成随机索引\n        let rng = @random.Rand::chacha8()\n        let random_index = rng.int(limit=moves.length())\n        match moves.get(random_index) {\n          Some(skill) => {\n            println(\" 敌人选择了技能: \" + skill.name)\n            execute_battle_skill(skill, false) // false 表示敌人攻击\n            end_current_turn()\n          }\n          None => {\n            println(\"❌ 敌人没有可用技能\")\n            end_current_turn()\n          }\n        }\n      } else {\n        println(\"❌ 敌人没有技能\")\n        end_current_turn()\n      }\n    }\n    None => {\n      println(\"❌ 没有找到敌人宝可梦\")\n      end_current_turn()\n    }\n  }\n}\n\n///|\n// 结束当前回合\npub fn end_current_turn() -> Unit {\n  match battle_render_state.battle_state {\n    Some(state) => {\n      // 首先检查战斗是否已经结束\n      if is_battle_finished(state) {\n        let winner = get_winner(state)\n        println(\" 战斗结束! \" + winner)\n        update_text_box(\"战斗结束! \" + winner)\n        \n        // 设置战斗状态为不活跃\n        let ended_state = BattleState::{\n          is_active: false,\n          turn: state.turn,\n          current_turn_type: state.current_turn_type,\n          player_pokemon: state.player_pokemon,\n          enemy_pokemon: state.enemy_pokemon,\n          battle_log: state.battle_log,\n          actions_this_turn: state.actions_this_turn,\n          max_actions_per_turn: state.max_actions_per_turn\n        }\n        battle_render_state.battle_state = Some(ended_state)\n        return\n      }\n      \n      if state.actions_this_turn >= state.max_actions_per_turn {\n        println(\"🔄 回合结束，切换到下一个回合\")\n        start_new_turn()\n        // 添加：如果切换到敌人回合，立即执行\n        if is_enemy_turn() {\n          execute_enemy_turn()\n        }\n      } else {\n        println(\"⚠️ 本回合还有行动次数剩余: \" + state.actions_this_turn.to_string() + \"/\" + state.max_actions_per_turn.to_string())\n      }\n    }\n    None => {\n      println(\"❌ 战斗状态未初始化\")\n    }\n  }\n}\n///|\n// 隐藏技能菜单UI\nfn hide_skill_menu_ui() -> Unit {\n  println(\"❌ 隐藏技能菜单UI\")\n  \n  // 清理技能菜单实体\n  clear_skill_menu_entities()\n  \n  // 重置技能菜单状态\n  battle_render_state.skill_menu_visible = false\n  battle_render_state.skill_menu_selected = 0\n  \n  println(\"技能菜单状态已重置\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// create a reference from value\npub fn[T] Ref::new(x : T) -> Ref[T] {\n  { val: x }\n}\n\n///|\ntest \"to_string\" {\n  inspect(new(3), content=\"{val: 3}\")\n}\n\n///|\n/// same as `Ref::new`\npub fn[T] new(x : T) -> Ref[T] {\n  { val: x }\n}\n\n///|\n/// Maps the value of a `Ref` using a given function.\n///\n/// # Example\n///\n/// ```mbt\n///   assert_eq(@ref.new(1).map((a) => { a + 1 }).val, 2)\n/// ```\npub fn[T, R] map(self : Ref[T], f : (T) -> R raise?) -> Ref[R] raise? {\n  { val: f(self.val) }\n}\n\n///|\n/// This function allows you to temporarily replace the value of a reference with a new value,\n/// execute a given function, and then restore the original value of the reference.\n///\n/// # Arguments\n///\n/// - `self`: The reference whose value will be temporarily replaced.\n/// - `a`: The new value to assign to the reference.\n/// - `f`: The function to execute while the reference value is replaced.\n///\n/// # Returns\n///\n/// The result of executing the provided function `f`.\n///\n/// # Example\n///\n/// ```mbt\n///   let x = @ref.new(1)\n///   x.protect(2, () => { x.val = 3 })\n///   assert_eq(x.val, 1)\n/// ```\npub fn[T, R] protect(self : Ref[T], a : T, f : () -> R raise?) -> R raise? {\n  let old = self.val\n  self.val = a\n  try f() catch {\n    err => {\n      self.val = old\n      raise err\n    }\n  } noraise {\n    r => {\n      self.val = old\n      r\n    }\n  }\n}\n\n///|\n/// Swaps the values of two references.\n///\n/// # Example\n///\n/// ```mbt\n///   let x = @ref.new(1)\n///   let y = @ref.new(2)\n///   @ref.swap(x, y)\n///   assert_eq(x.val, 2)\n///   assert_eq(y.val, 1)\n/// ```\npub fn[T] Ref::swap(self : Ref[T], that : Ref[T]) -> Unit {\n  let tmp = self.val\n  self.val = that.val\n  that.val = tmp\n}\n\n///|\npub fnalias Ref::swap\n\n///|\ntest \"swap\" {\n  let x = new(1)\n  let y = new(2)\n  swap(x, y)\n  inspect(x.val, content=\"2\")\n  inspect(y.val, content=\"1\")\n}\n\n///|\npub fn[T] update(self : Ref[T], f : (T) -> T raise?) -> Unit raise? {\n  self.val = f(self.val)\n}\n\n///|\ntest \"decr\" {\n  let a = new(1)\n  a.val -= 1\n  inspect(a.val, content=\"0\")\n  a.val -= 5\n  inspect(a.val, content=\"-5\")\n}\n\n///|\ntest \"incr\" {\n  let a = new(1)\n  a.val += 1\n  inspect(a.val, content=\"2\")\n  a.val += 5\n  inspect(a.val, content=\"7\")\n}\n\n///|\npub impl[X : @quickcheck.Arbitrary] @quickcheck.Arbitrary for Ref[X] with arbitrary(\n  size,\n  rs,\n) {\n  new(X::arbitrary(size, rs))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n///|\npriv struct Entry[K] {\n  mut prev : Int\n  mut next : Entry[K]?\n  mut psl : Int\n  hash : Int\n  key : K\n} derive(Show)\n\n///|\n/// Mutable linked hash set that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt\n///   let set = Set::of([\"three\", \"eight\", \"one\"])\n///   assert_eq(set.contains(\"two\"), false)\n///   assert_eq(set.contains(\"three\"), true)\n///   set.add(\"three\") // no effect since it already exists\n///   set.add(\"two\")\n///   assert_eq(set.contains(\"two\"), true)\n/// ```\nstruct Set[K] {\n  mut entries : FixedArray[Entry[K]?]\n  mut size : Int // active keys count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash set.\n/// The capacity of the set will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K] Set::new(capacity? : Int = 8) -> Set[K] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash set from array.\npub fn[K : Hash + Eq] Set::from_array(arr : Array[K]) -> Set[K] {\n  let m = Set::new(capacity=arr.length())\n  arr.each(e => m.add(e))\n  m\n}\n\n///|\n/// Insert a key into the hash set.\n///\n/// Parameters:\n///\n/// * `set` : The hash set to modify.\n/// * `key` : The key to insert. Must implement `Hash` and `Eq` traits.\n///\n/// Example:\n///\n/// ```moonbit\n///   let set : Set[String] = Set::new()\n///   set.add(\"key\")\n///   inspect(set.contains(\"key\"), content=\"true\")\n///   set.add(\"key\") // no effect since it already exists\n///   inspect(set.size(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq] add(self : Set[K], key : K) -> Unit {\n  self.add_with_hash(key, key.hash())\n}\n\n///|\nfn[K : Eq] add_with_hash(self : Set[K], key : K, hash : Int) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K] push_away(self : Set[K], idx : Int, entry : Entry[K]) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K] set_entry(self : Set[K], entry : Entry[K], new_idx : Int) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Insert a key into the hash set and returns whether the key was successfully added.\n///\n/// Parameters:\n///\n/// * `set` : The hash set to modify.\n/// * `key` : The key to insert. Must implement `Hash` and `Eq` traits.\n///\n/// Returns `true` if the key was successfully added (i.e., it wasn't already present),\n/// `false` if the key already existed in the set.\n///\n/// Example:\n///\n/// ```moonbit\n///   let set : Set[String] = Set::new()\n///   inspect(set.add_and_check(\"key\"), content=\"true\")  // First insertion\n///   inspect(set.add_and_check(\"key\"), content=\"false\") // Already exists\n///   inspect(set.size(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq] add_and_check(self : Set[K], key : K) -> Bool {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let hash = key.hash()\n  let (idx, psl, added) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl, true)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          break (idx, psl, false)\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl, true)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  if added {\n    let entry = { prev: self.tail, next: None, psl, key, hash }\n    self.add_entry_to_tail(idx, entry)\n  }\n  added\n}\n\n///|\n/// Check if the hash set contains a key.\npub fn[K : Hash + Eq] Set::contains(self : Set[K], key : K) -> Bool {\n  // inline lookup to avoid unnecessary allocations\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Remove a key from the hash set. If the key exists in the set, removes it\n/// and adjusts the probe sequence length (PSL) of subsequent entries to\n/// maintain the Robin Hood hashing invariant. If the key does not exist,\n/// the set remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash set to remove the key from.\n/// * `key` : The key to remove from the set.\n///\n/// Example:\n///\n/// ```moonbit\n///   let set = Set::of([\"a\", \"b\"])\n///   set.remove(\"a\")\n///   inspect(set.contains(\"a\"), content=\"false\")\n///   inspect(set.size(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq] remove(self : Set[K], key : K) -> Unit {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Remove a key from the hash set and returns whether the key was successfully removed.\n///\n/// Parameters:\n///\n/// * `set` : The hash set to modify.\n/// * `key` : The key to remove. Must implement `Hash` and `Eq` traits.\n///\n/// Returns `true` if the key was successfully removed (i.e., it was present),\n/// `false` if the key didn't exist in the set.\n///\n/// Example:\n///\n/// ```moonbit\n///   let set = Set::of([\"a\", \"b\"])\n///   inspect(set.remove_and_check(\"a\"), content=\"true\")  // Successfully removed\n///   inspect(set.remove_and_check(\"a\"), content=\"false\") // Already removed\n///   inspect(set.size(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq] remove_and_check(self : Set[K], key : K) -> Bool {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K] add_entry_to_tail(self : Set[K], idx : Int, entry : Entry[K]) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K] remove_entry(self : Set[K], entry : Entry[K]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K] shift_back(self : Set[K], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq] grow(self : Set[K]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, hash, .. }) => {\n      self.add_with_hash(key, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n// Utils\n\n///|\npub impl[K : Show] Show for Set[K] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger.write_object(key)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of keys in the set.\npub fn[K] size(self : Set[K]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the set.\npub fn[K] capacity(self : Set[K]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash set is empty.\npub fn[K] is_empty(self : Set[K]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all keys of the set in the order of insertion.\n#locals(f)\npub fn[K] each(self : Set[K], f : (K) -> Unit raise?) -> Unit raise? {\n  loop self.head {\n    Some({ key, next, .. }) => {\n      f(key)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all keys of the set in the order of insertion, with index.\n#locals(f)\npub fn[K] eachi(self : Set[K], f : (Int, K) -> Unit raise?) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, next, .. })) => {\n      f(i, key)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the set, removing all keys. Keeps the allocated space.\npub fn[K] clear(self : Set[K]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash set, provide elements in the order of insertion.\npub fn[K] iter(self : Set[K]) -> Iter[K] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, next, .. }) => {\n      guard yield_(key) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => break IterContinue\n  })\n}\n\n///|\n/// Converts the hash set to an array.\npub fn[K] to_array(self : Set[K]) -> Array[K] {\n  let arr = Array::new(capacity=self.size)\n  loop self.head {\n    Some({ key, next, .. }) => {\n      arr.push(key)\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq] Eq for Set[K] with op_equal(self, other) {\n  guard self.size == other.size else { return false }\n  for k in self {\n    guard other.contains(k) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq] Set::of(arr : FixedArray[K]) -> Set[K] {\n  let length = arr.length()\n  let m = Set::new(capacity=length)\n  for i in 0..<length {\n    let e = arr[i]\n    m.add(e)\n  }\n  m\n}\n\n///|\npub fn[K : Hash + Eq] Set::from_iter(iter : Iter[K]) -> Set[K] {\n  let m = Set::new()\n  for e in iter {\n    m.add(e)\n  }\n  m\n}\n\n///|\npub impl[K] Default for Set[K] with default() {\n  Set::new()\n}\n\n///|\n/// Copy the set, creating a new set with the same keys and order of insertion.\npub fn[K] copy(self : Set[K]) -> Set[K] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\npub fn[K : Hash + Eq] difference(self : Set[K], other : Set[K]) -> Set[K] {\n  let m = Set::new()\n  self.each(k => if !other.contains(k) { m.add(k) })\n  m\n}\n\n///|\npub fn[K : Hash + Eq] symmetric_difference(\n  self : Set[K],\n  other : Set[K],\n) -> Set[K] {\n  let m = Set::new()\n  self.each(k => if !other.contains(k) { m.add(k) })\n  other.each(k => if !self.contains(k) { m.add(k) })\n  m\n}\n\n///|\npub fn[K : Hash + Eq] union(self : Set[K], other : Set[K]) -> Set[K] {\n  let m = Set::new()\n  self.each(k => m.add(k))\n  other.each(k => m.add(k))\n  m\n}\n\n///|\npub fn[K : Hash + Eq] intersection(self : Set[K], other : Set[K]) -> Set[K] {\n  let m = Set::new()\n  self.each(k => if other.contains(k) { m.add(k) })\n  m\n}\n\n///|\npub impl[X : ToJson] ToJson for Set[X] with to_json(self) {\n  let res = Array::new(capacity=self.size)\n  for v in self {\n    res.push(v.to_json())\n  }\n  Json::array(res)\n}\n\n///|\n/// Check if two sets have no common elements.\npub fn[K : Hash + Eq] is_disjoint(self : Set[K], other : Set[K]) -> Bool {\n  if self.size() <= other.size() {\n    for k in self {\n      if other.contains(k) {\n        return false\n      }\n    }\n  } else {\n    for k in other {\n      if self.contains(k) {\n        return false\n      }\n    }\n  }\n  true\n}\n\n///|\n/// Check if the current set is a subset of another set.\npub fn[K : Hash + Eq] is_subset(self : Set[K], other : Set[K]) -> Bool {\n  if self.size() <= other.size() {\n    for k in self {\n      if !other.contains(k) {\n        return false\n      }\n    }\n    true\n  } else {\n    false\n  }\n}\n\n///|\n/// Check if the current set is a superset of another set.\npub fn[K : Hash + Eq] is_superset(self : Set[K], other : Set[K]) -> Bool {\n  other.is_subset(self)\n}\n\n///|\n/// Intersection of two hash sets.\npub impl[K : Hash + Eq] BitAnd for Set[K] with land(self, other) {\n  self.intersection(other)\n}\n\n///|\n/// Union of two hash sets.\npub impl[K : Hash + Eq] BitOr for Set[K] with lor(self, other) {\n  self.union(other)\n}\n\n///|\n/// Symmetric difference of two hash sets.\npub impl[K : Hash + Eq] BitXOr for Set[K] with lxor(self, other) {\n  self.symmetric_difference(other)\n}\n\n///|\n/// Difference of two hash sets.\npub impl[K : Hash + Eq] Sub for Set[K] with op_sub(self, other) {\n  self.difference(other)\n}\n\n///|\npub fnalias Set::(new, from_array, from_iter, of)\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  op_equal(Self, Self) -> Bool\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit\n  write_substring(Self, String, Int, Int) -> Unit\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n// Default implementation for `Show::to_string`, uses a `Buffer`\n///|\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder(Ref[String])\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  ignore(size_hint)\n  { val: \"\" }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.val == \"\"\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.val += str\n}\n\n///|\n#intrinsic(\"%char.to_string\")\nfn char_to_string(char : Char) -> String {\n  [char]\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.val += char_to_string(ch)\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sb = StringBuilder::new()\n///   sb.write_substring(\"Hello, world!\", 0, 5)\n///   assert_eq(sb.to_string(), \"Hello\")\n/// ```\npub impl Logger for StringBuilder with write_substring(\n  self : StringBuilder,\n  str : String,\n  start : Int,\n  len : Int,\n) -> Unit {\n  self.val += str.substring(start~, end=start + len)\n}\n\n///|\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(self.val)\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.val\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.val = \"\"\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  self.to_int().output(logger)\n}\n\n///|\nfn to_hex_digit(i : Int) -> Char {\n  if i < 10 {\n    (i + '0').unsafe_to_char()\n  } else {\n    (i + 'a' - 10).unsafe_to_char()\n  }\n}\n\n///|\ntest \"to_hex_digit\" {\n  for i in 0..<10 {\n    guard to_hex_digit(i) == ('0'.to_int() + i).unsafe_to_char() else {\n      fail(\"to_hex_digit(\\{i}) does not match\")\n    }\n  }\n  for i in 10..<16 {\n    guard to_hex_digit(i) == ('a'.to_int() + (i - 10)).unsafe_to_char() else {\n      fail(\"to_hex_digit(\\{i}) does not match\")\n    }\n  }\n}\n\n///|\npub impl Show for Bytes with output(self, logger) {\n  logger.write_string(\"b\\\"\")\n  for b in self {\n    let byte = b.to_int()\n    logger\n    ..write_string(\"\\\\x\")\n    ..write_char(to_hex_digit(byte / 16))\n    ..write_char(to_hex_digit(byte % 16))\n  }\n  logger.write_string(\"\\\"\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_char(to_hex_digit(code / 16))\n          ..write_char(to_hex_digit(code % 16))\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for Ref[X] with output(self, logger) {\n  logger..write_string(\"{val: \")..write_object(self.val)..write_string(\"}\")\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```moonbit\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.get\")\npub fn[T] Array::op_get(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\nfn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// ```\n///\n#intrinsic(\"%array.set\")\npub fn[T] Array::op_set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// ```\npub impl[T : Eq] Eq for Array[T] with op_equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// ```\npub impl[T] Add for Array[T] with op_add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// ```\npub fn[T] Array::append(self : Array[T], other : Array[T]) -> Unit {\n  other.blit_to(\n    self,\n    len=other.length(),\n    src_offset=0,\n    dst_offset=self.length(),\n  )\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each((x) => { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each((x) => { sum = sum - x })\n///   @json.inspect(sum, content=-12)\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => { sum = sum + x + i })\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```moonbit\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => {sum = sum + x + i})\n///   inspect(sum, content=\"15\")\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.map((x) => {x + 1})\n///   assert_eq(v2, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.map_inplace((x) => {x + 1})\n///   assert_eq(v, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T] Array::map_inplace(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => {x + i})\n///   assert_eq(v2, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.mapi_inplace((i, x) => {x + i})\n///   assert_eq(v, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T] Array::mapi_inplace(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter((x) => { x % 2 == 0 })\n///   inspect(evens, content=\"[2, 4]\")\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Tests whether the array is sorted in ascending order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be tested.\n/// * `T` : The type of elements in the array. Must implement the `Compare`\n/// trait.\n///\n/// Returns a boolean value indicating whether the array is sorted in ascending\n/// order:\n///\n/// * `true` if the array is empty, contains only one element, or all elements\n/// are in ascending order.\n/// * `false` if any element is greater than the element that follows it.\n///\n/// Example:\n///\n/// ```moonbit\n///   let ascending = [1, 2, 3, 4, 5]\n///   let descending = [5, 4, 3, 2, 1]\n///   let unsorted = [1, 3, 2, 4, 5]\n///   inspect(ascending.is_sorted(), content=\"true\")\n///   inspect(descending.is_sorted(), content=\"false\")\n///   inspect(unsorted.is_sorted(), content=\"false\")\n/// ```\npub fn[T : Compare] Array::is_sorted(self : Array[T]) -> Bool {\n  for i = 1 {\n    if i >= self.length() {\n      break true\n    }\n    if self[i - 1] > self[i] {\n      break false\n    }\n    continue i + 1\n  }\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_inplace()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///\n///   let arr : Array[Int] = []\n///   arr.rev_inplace()\n///   inspect(arr, content=\"[]\")\n/// ```\npub fn[T] Array::rev_inplace(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let (v1, v2) = v.split_at(1)\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// ```\n/// TODO: perf could be optimized\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  if suffix.length() > self.length() {\n    return false\n  }\n  for i in 0..<suffix.length() {\n    if self.unsafe_get(self.length() - suffix.length() + i) !=\n      suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  for i, v in self {\n    if v == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by((x) => { x == 3 }) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// ```\n#locals(f)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by((x) => {\n///     x.compare(3)\n///   })\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by((x) => {\n///     x.compare(4)\n///   })\n///   inspect(find_4, content=\"Err(2)\")\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\n#locals(cmp)\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain((x) => { x % 2 == 0 })\n///   inspect(arr, content=\"[2, 4]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.retain((x) => { x > 10 })\n///   inspect(arr, content=\"[]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens a array of arrays into a array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create a array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#locals(f)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#locals(f)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if((x) => { x % 2 == 0 })\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let v = []\n  let indices = []\n  for i in 0..<self.length() {\n    if f(self[i]) {\n      v.push(self[i])\n      indices.push(i)\n    }\n  }\n  for i in 0..<indices.length() {\n    self.remove(indices[i] - i) |> ignore\n  }\n  v\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[Array[T]] {\n  guard size > 0\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = Array::new(capacity=size)\n    for j = 0; j < size && i < self.length(); j = j + 1 {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n  }\n  chunks\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => { x <= y })\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => { x <= y }), content=\"[]\")\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    chunk.push(self[i])\n    i = i + 1\n    while i < self.length() && pred(self[i - 1], self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n  }\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  let windows = Array::new(capacity=len)\n  for i in 0..<len {\n    windows.push(self[i:i + size])\n  }\n  windows\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split((x) => { x == 0 }), content=\"[[1], [2], [3], [4]]\")\n///\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split((x) => { x == 0 }), content=\"[[], [1], [], [2]]\")\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each((x) => { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// ```\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  Iter::new(yield_ => for v in self {\n    guard yield_(v) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each((x) => { result.push(x) })\n///   inspect(result, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  Iter::new(yield_ => for i = self.length() - 1; i >= 0; i = i - 1 {\n    guard yield_(self.unsafe_get(i)) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => { sum = sum + i + x })\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// ```\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  Iter2::new(yield_ => for i, v in self {\n    guard yield_(i, v) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.truncate(3)\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.retain_map(fn(x) {\n///   if x % 2 == 0 {\n///     Some(x * 2)\n///   } else {\n///     None\n///   }\n/// })\n/// inspect(arr,content = \"[4, 8]\")\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let h1 = Hasher::new() // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// ```\npub fn Hasher::new(seed? : Int = 0) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_float(3.14)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// ```\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\n/// Implements the `Hash` trait for integer values using a combination of shifts\n/// and multiplications to produce a well-distributed hash value. Based on the\n/// hash algorithm from hash-prospector\n/// (https://github.com/skeeto/hash-prospector).\n///\n/// Parameters:\n///\n/// * `integer` : The integer value to be hashed. The value will be reinterpreted\n/// as an unsigned integer before hashing to ensure consistent behavior across\n/// positive and negative values.\n///\n/// Returns a 32-bit hash value derived from the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 42\n///   inspect(Hash::hash(x), content=\"-1704501356\")\n///   let y = -42\n///   inspect(Hash::hash(y), content=\"1617647962\")\n/// ```\npub impl Hash for Int with hash(self) {\n  let self = self.reinterpret_as_uint()\n  let mut x = self ^ (self >> 17)\n  x = x * 0xed5ad4bb\n  x = x ^ (x >> 11)\n  x = x * 0xac4c1b51\n  x = x ^ (x >> 15)\n  x = x * 0x31848bab\n  x = x ^ (x >> 14)\n  x.reinterpret_as_int()\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new()\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new()\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates an iterator that iterates over a range of Int with default step 1.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Int::upto(self : Int, end : Int, inclusive? : Bool = false) -> Iter[Int] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of UInt with default step 1U.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of UInt from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn UInt::upto(\n  self : UInt,\n  end : UInt,\n  inclusive? : Bool = false,\n) -> Iter[UInt] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of UInt64 with default step 1UL.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of UInt64 from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn UInt64::upto(\n  self : UInt64,\n  end : UInt64,\n  inclusive? : Bool = false,\n) -> Iter[UInt64] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Int64 with default step 1L.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int64 from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Int64::upto(\n  self : Int64,\n  end : Int64,\n  inclusive? : Bool = false,\n) -> Iter[Int64] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Float::upto(\n  self : Float,\n  end : Float,\n  inclusive? : Bool = false,\n) -> Iter[Float] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Double with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Double from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Double::upto(\n  self : Double,\n  end : Double,\n  inclusive? : Bool = false,\n) -> Iter[Double] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Searches the array for the first element that satisfies the predicate\n/// function.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element satisfies the search condition.\n///\n/// Returns the index of the first element that satisfies the predicate, or\n/// `None` if no such element is found.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.search_by((x) => { x > 3 }), content=\"Some(3)\")\n///   inspect(arr.search_by((x) => { x > 10 }), content=\"None\")\n/// ```\n///\n#deprecated(\"Use `search_by` instead.\")\n#coverage.skip\npub fn[T] Array::find_index(self : Array[T], f : (T) -> Bool) -> Int? {\n  self.search_by(f)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#deprecated(\"Use `fold` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_left(\n  self : Array[T],\n  f : (U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.fold(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#deprecated(\"Use `rev_fold` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_right(\n  self : Array[T],\n  f : (U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.rev_fold(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#deprecated(\"Use `foldi` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_lefti(\n  self : Array[T],\n  f : (Int, U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.foldi(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#deprecated(\"Use `rev_foldi` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_righti(\n  self : Array[T],\n  f : (Int, U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.rev_foldi(init~, f)\n}\n\n///|\n#deprecated(\"Use `unsafe_pop` instead\")\n#coverage.skip\npub fn[T] Array::pop_exn(self : Array[T]) -> T {\n  self.unsafe_pop()\n}\n\n///|\n/// Creates a byte sequence from a UTF-16 encoded string. Each character in the\n/// string is encoded as a pair of bytes in little-endian order.\n///\n/// Parameters:\n///\n/// * `string` : The input string to be converted to a byte sequence.\n///\n/// Returns a new byte sequence containing the UTF-16LE encoded representation of\n/// the input string.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = \"ABC\".to_bytes()\n///   inspect(bytes, content=\"b\\\"\\\\x41\\\\x00\\\\x42\\\\x00\\\\x43\\\\x00\\\"\")\n/// ```\n#deprecated(\"Use `str.to_bytes()` instead\")\npub fn Bytes::of_string(str : String) -> Bytes {\n  FixedArray::make(str.length() * 2, Byte::default())\n  ..blit_from_string(0, str, 0, str.length())\n  .unsafe_reinterpret_as_bytes()\n}\n\n///|\n#deprecated(\"Bytes are immutable. Use `FixedArray::blit_from_bytes` if it's really necessary.\")\npub fn Bytes::copy(self : Bytes) -> Bytes {\n  Bytes::makei(self.length(), i => self[i])\n}\n\n///|\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the bitwise left shift operation.\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Byte::lsl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// bits.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to be shifted.\n/// - `count` : The number of bits to shift the `value` to the right.\n///\n/// Returns the result of the logical shift right operation as a `Byte`.\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Byte::lsr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n\n///|\n/// Prints and returns the value of a given expression for quick and dirty debugging.\n#callsite(autofill(loc))\n#deprecated(\"This function is for debugging only and should not be used in production\")\npub fn[T] dump(t : T, name? : String, loc~ : SourceLoc) -> T {\n  let name = match name {\n    Some(name) => name\n    None => \"\"\n  }\n  println(\"dump(\\{name}@\\{loc}) = \\{any_to_string(t)}\")\n  t\n}\n\n///|\n/// Returns the Unicode code point at the given index.\n///\n/// This method counts Unicode code points (characters) rather than UTF-16 code units.\n/// It properly handles surrogate pairs to return the correct Unicode character.\n///\n/// # Examples\n///\n/// ```mbt\n/// let s = \"Hello🤣\"\n/// inspect(s.get_char(0).unwrap(), content=\"H\")\n/// inspect(s.get_char(5).unwrap(), content=\"🤣\")\n/// ```\n///\n/// # Panics\n///\n/// Panics if:\n/// - The index is out of bounds\n/// - The string contains an invalid surrogate pair\n#deprecated(\"The index will be changed to utf16 index. If you want to access n-th character, use `str.iter().nth(n).unwrap()` instead.\")\npub fn String::codepoint_at(self : String, index : Int) -> Char {\n  let charcode_len = self.length()\n  guard index >= 0 && index < charcode_len else { abort(\"index out of bounds\") }\n  for char_count = 0, utf16_offset = 0\n      char_count < charcode_len && utf16_offset < index\n      char_count = char_count + 1, utf16_offset = utf16_offset + 1 {\n    let c1 = self.unsafe_charcode_at(char_count)\n    if c1.is_leading_surrogate() && char_count + 1 < charcode_len {\n      let c2 = self.unsafe_charcode_at(char_count + 1)\n      if c2.is_trailing_surrogate() {\n        continue char_count + 2, utf16_offset + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    guard utf16_offset == index && char_count < charcode_len else {\n      abort(\"index out of bounds\")\n    }\n    let c1 = self.unsafe_charcode_at(char_count)\n    if c1.is_leading_surrogate() && char_count + 1 < charcode_len {\n      let c2 = self.unsafe_charcode_at(char_count + 1)\n      if c2.is_trailing_surrogate() {\n        code_point_of_surrogate_pair(c1, c2)\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    } else {\n      c1.unsafe_to_char()\n    }\n  }\n}\n\n///|\n#deprecated(\"Use `char_length` instead.\")\npub fn String::codepoint_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  self.char_length(start_offset~, end_offset?)\n}\n\n///|\n#deprecated(\"Use `s[i]` instead\")\npub fn String::charcode_at(self : String, index : Int) -> Int {\n  self[index]\n}\n\n///|\n/// Returns the Unicode code point at the given index without bounds checking.\n#deprecated(\"Use `s.get_char(i).unwrap()` instead\")\npub fn String::unsafe_char_at(self : String, index : Int) -> Char {\n  let c1 = self.unsafe_charcode_at(index)\n  if c1.is_leading_surrogate() {\n    let c2 = self.unsafe_charcode_at(index + 1)\n    code_point_of_surrogate_pair(c1, c2)\n  } else {\n    c1.unsafe_to_char()\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn Int64::output(self : Int64, logger : &Logger, radix? : Int = 10) -> Unit {\n  fn abs(n : Int64) -> Int64 {\n    if n < 0L {\n      0L - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0L {\n    logger.write_char('-')\n  }\n  let radix : Int64 = radix.to_int64()\n  fn write_digits(num : Int64) {\n    let num2 = num / radix\n    if num2 != 0L {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at(abs(num % radix).to_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn Int::output(self : Int, logger : &Logger, radix? : Int = 10) -> Unit {\n  fn abs(n : Int) -> Int {\n    if n < 0 {\n      0 - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0 {\n    logger.write_char('-')\n  }\n  fn write_digits(num : Int) {\n    let num2 = num / radix\n    if num2 != 0 {\n      write_digits(num2)\n    }\n    logger.write_char(ALPHABET.charcode_at(abs(num % radix)).unsafe_to_char())\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn UInt::output(self : UInt, logger : &Logger, radix? : Int = 10) -> Unit {\n  let radix : UInt = radix.reinterpret_as_uint()\n  fn write_digits(num : UInt) {\n    let num2 = num / radix\n    if num2 != 0U {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at((num % radix).reinterpret_as_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn UInt64::output(self : UInt64, logger : &Logger, radix? : Int = 10) -> Unit {\n  let radix : UInt64 = radix.to_uint64()\n  fn write_digits(num : UInt64) {\n    let num2 = num / radix\n    if num2 != 0UL {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at((num % radix).to_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn Int64::output_size_hint(radix? : Int = 10) -> Int {\n  match radix {\n    2..<7 => 70 // max length is 64, 70 is enough\n    8..<15 => 30 // max length is 23, 30 is enough\n    16..=36 => 20 // max length is 17, 20 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn Int::output_size_hint(radix? : Int = 10) -> Int {\n  match radix {\n    2..<7 => 36 // max length is 32, 36 is enough\n    8..<15 => 18 // max length is 12, 18 is enough\n    16..=36 => 10 // max length is 8, 10 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn UInt::output_size_hint(radix? : Int = 10) -> Int {\n  Int::output_size_hint(radix~)\n}\n\n///|\nfn UInt64::output_size_hint(radix? : Int = 10) -> Int {\n  Int64::output_size_hint(radix~)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int16::to_string(self : Int16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for Int16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for UInt16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"to_string with radix\" {\n  // Binary\n  inspect((0).to_string(radix=2), content=\"0\")\n  inspect((1).to_string(radix=2), content=\"1\")\n  inspect((2).to_string(radix=2), content=\"10\")\n  inspect((255).to_string(radix=2), content=\"11111111\")\n  inspect((-255).to_string(radix=2), content=\"-11111111\")\n\n  // Octal\n  inspect((0).to_string(radix=8), content=\"0\")\n  inspect((8).to_string(radix=8), content=\"10\")\n  inspect((64).to_string(radix=8), content=\"100\")\n  inspect((-64).to_string(radix=8), content=\"-100\")\n\n  // Decimal\n  inspect((0).to_string(radix=10), content=\"0\")\n  inspect((123).to_string(radix=10), content=\"123\")\n  inspect((-123).to_string(radix=10), content=\"-123\")\n  inspect(\n    0x7fff_ffff_ffff_ffffL.to_string(radix=10),\n    content=\"9223372036854775807\",\n  )\n  inspect(\n    0x8000_0000_0000_0000L.to_string(radix=10),\n    content=\"-9223372036854775808\",\n  )\n\n  // Hexadecimal\n  inspect((0).to_string(radix=16), content=\"0\")\n  inspect((0x11).to_string(radix=16), content=\"11\")\n  inspect((0x15ef).to_string(radix=16), content=\"15ef\")\n  inspect((-0xabcd).to_string(radix=16), content=\"-abcd\")\n  inspect(\n    (1.0 : Float).reinterpret_as_int().to_string(radix=16),\n    content=\"3f800000\",\n  )\n\n  // UInt\n  inspect(0U.to_string(radix=16), content=\"0\")\n  inspect(0x1AU.to_string(radix=16), content=\"1a\")\n  inspect(0xabcdU.to_string(radix=16), content=\"abcd\")\n  inspect(\n    (-2.0 : Float).reinterpret_as_uint().to_string(radix=16),\n    content=\"c0000000\",\n  )\n  inspect((-1).reinterpret_as_uint().to_string(radix=16), content=\"ffffffff\")\n\n  // Int64\n  inspect(0L.to_string(radix=16), content=\"0\")\n  inspect(0x2fL.to_string(radix=16), content=\"2f\")\n  inspect(0xf0aeL.to_string(radix=16), content=\"f0ae\")\n  inspect((-0x1234eacbL).to_string(radix=16), content=\"-1234eacb\")\n  inspect(\n    1.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"3ff0000000000000\",\n  )\n  inspect(0b101L.to_string(radix=2), content=\"101\")\n  inspect(0o17L.to_string(radix=8), content=\"17\")\n\n  // UInt64\n  inspect(0UL.to_string(radix=16), content=\"0\")\n  inspect(0x11UL.to_string(radix=16), content=\"11\")\n  inspect(0x12bdUL.to_string(radix=16), content=\"12bd\")\n  inspect(\n    (-1L).reinterpret_as_uint64().to_string(radix=16),\n    content=\"ffffffffffffffff\",\n  )\n  inspect(\n    2.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"4000000000000000\",\n  )\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n///|\n/// Create new string of `length`, where each character is `value`\n///\n/// ```mbt\n///   assert_eq(String::make(5,'S'), \"SSSSS\")\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  guard length >= 0 else { abort(\"invalid length\") }\n  if value.to_int() <= 0xFFFF {\n    unsafe_make_string(length, value)\n  } else {\n    let buf = StringBuilder::new(size_hint=2 * length)\n    for _ in 0..<length {\n      buf.write_char(value)\n    }\n    buf.to_string()\n  }\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  ((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000).unsafe_to_char()\n}\n\n///|\n/// Returns the number of Unicode code points (characters) in the string.\n///\n/// This method counts actual Unicode characters, properly handling surrogate pairs\n/// that represent single characters like emojis. For the raw UTF-16 code unit count,\n/// use `length()` instead.\n///\n/// # Examples\n///\n/// ```mbt\n///   let s = \"Hello🤣\";\n///   inspect(s.char_length(), content = \"6\"); // 6 actual characters\n///   inspect(s.length(), content = \"7\");  // 5 ASCII chars + 2 surrogate pairs\n/// ```\npub fn String::char_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"invalid start or end index for String::codepoint_length\")\n  }\n  for utf16_index = start_offset, char_count = 0\n      utf16_index < end_offset\n      utf16_index = utf16_index + 1, char_count = char_count + 1 {\n    let c1 = self.unsafe_charcode_at(utf16_index)\n    if c1.is_leading_surrogate() && utf16_index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(utf16_index + 1)\n      if c2.is_trailing_surrogate() {\n        continue utf16_index + 2, char_count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    char_count\n  }\n}\n\n///|\n#intrinsic(\"%string.substring\")\nfn unsafe_substring(str : String, start : Int, end : Int) -> String {\n  let len = end - start\n  let bytes = FixedArray::make(len * 2, Byte::default())\n  bytes.blit_from_string(0, str, start, len)\n  bytes.unsafe_reinterpret_as_bytes().to_unchecked_string()\n}\n\n///|\n/// Returns a new string containing characters from the original string starting\n/// at `start` index up to (but not including) `end` index.\n///\n/// Parameters:\n///\n/// * `string` : The source string from which to extract the substring.\n/// * `start` : The starting index of the substring (inclusive). Defaults to 0.\n/// * `end` : The ending index of the substring (exclusive). Defaults to the\n/// length of the string.\n///\n/// Returns a new string containing the specified substring.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s = \"Hello world\"\n///   inspect(s.substring(start=0, end=5), content=\"Hello\")\n///   inspect(s.substring(start=6, end=11), content=\"world\")\n///   inspect(s.substring(), content=\"Hello world\")\n///\n///   let s = \"test\"\n///   inspect(s.substring(start=2, end=2), content=\"\")\n///   inspect(\"\".substring(), content=\"\")\n/// ```\npub fn String::substring(self : String, start? : Int = 0, end? : Int) -> String {\n  let len = self.length()\n  let end = match end {\n    Some(end) => end\n    None => len\n  }\n  guard start >= 0 && start <= end && end <= len\n  unsafe_substring(self, start, end)\n}\n\n///|\ntest \"substring/empty\" {\n  let s = \"test\"\n  inspect(s.substring(start=2, end=2), content=\"\")\n  inspect(s.substring(start=4, end=4), content=\"\")\n  inspect(\"\".substring(), content=\"\")\n}\n\n///|\ntest \"panic substring/invalid_range\" {\n  let s = \"test\"\n  ignore(s.substring(start=-1))\n  ignore(s.substring(end=5))\n  ignore(s.substring(start=3, end=2))\n}\n\n///|\ntest \"substring/basic\" {\n  inspect(\"Hello world\".substring(start=0, end=5), content=\"Hello\")\n  inspect(\"Hello world\".substring(start=6, end=11), content=\"world\")\n  inspect(\"Hello world\".substring(start=0), content=\"Hello world\")\n  inspect(\"Hello world\".substring(start=6), content=\"world\")\n}\n\n///|\ntest \"substring/boundary\" {\n  inspect(\"\".substring(start=0, end=0), content=\"\")\n  inspect(\"a\".substring(start=0, end=1), content=\"a\")\n  inspect(\"abc\".substring(start=0), content=\"abc\")\n  inspect(\"abc\".substring(start=1), content=\"bc\")\n  inspect(\"abc\".substring(start=0, end=3), content=\"abc\")\n}\n\n///|\ntest \"panic substring/out_of_bounds\" {\n  ignore(\"hello\".substring(start=-1, end=4))\n  ignore(\"hello\".substring(start=6, end=4))\n  ignore(\"hello\".substring(start=0, end=6))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with op_equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt\n///   let map = { 3: \"three\", 8 :  \"eight\", 1 :  \"one\"}\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : Array[(K, V)]) -> Map[K, V] {\n  let m = Map::new(capacity=arr.length())\n  arr.each(e => m.set(e.0, e.1))\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map : Map[String, Int] = Map::new()\n///   map.set(\"key\", 42)\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   map.set(\"key\", 24) // update existing key\n///   inspect(map.get(\"key\"), content=\"Some(24)\")\n/// ```\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Sets the value associated with a key in the hash map. If the key already\n/// exists, updates its value; otherwise, adds a new key-value pair. This\n/// function is automatically called when using the index assignment syntax\n/// `map[key] = value`.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to associate with the value. Must implement `Hash` and `Eq`\n/// traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map : Map[String, Int] = Map::new()\n///   map[\"key\"] = 42\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n/// ```\npub fn[K : Hash + Eq, V] Map::op_set(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Unit {\n  self.set(key, value)\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"key\": 42 }\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   inspect(map.get(\"nonexistent\"), content=\"None\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::op_get(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          self.push_away(idx, entry)\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// \n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"a\": 1, \"b\": 2 }\n///   map.remove(\"a\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.size(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\npub fn[K, V] Map::size(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, value, next, .. }) => {\n      guard yield_((key, value)) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => break IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  Iter2::new(yield_ => loop self.head {\n    Some({ key, value, next, .. }) => {\n      guard yield_(key, value) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, next, .. }) => {\n      guard yield_(key) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  Iter::new(yield_ => loop self.head {\n    Some({ value, next, .. }) => {\n      guard yield_(value) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with op_equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let m = Map::new(capacity=length)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  for e in iter {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```moonbit\n/// let map = { \"a\": 1, \"b\": 2 }\n///\n/// // Update existing value\n/// map.update(\"a\", fn(v) { \n///   match v { \n///     Some(x) => Some(x + 10) \n///     None => Some(0) \n///   } \n/// })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"b\": 2}\n/// ))\n///\n/// // Insert new value\n/// map.update(\"c\", fn(v) { \n///   match v { \n///     Some(x) => Some(x) \n///     None => Some(3) \n///   } \n/// })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"b\": 2, \"c\": 3}\n/// ))\n///\n/// // Remove existing value\n/// map.update(\"b\", fn(_) { None })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"c\": 3}\n/// ))\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```moonbit\n/// inspect((0xD800).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n/// inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0xD800).is_surrogate(), content=\"true\")  // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\")  // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\")  // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\")   // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") // 😀 emoji codepoint\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```moonbit skip\n///   println(42)\n///   println(\"Hello, World!\")\n///   println([1, 2, 3])\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x : Int = 42\n///   inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"a中\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣a\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣中\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```moonbit skip\n///   inspect(42, content=\"42\")\n///   inspect(\"hello\", content=\"hello\")\n///   inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content? : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_string().escape()\n    let args_loc = args_loc.to_json().escape()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```moonbit\n///   let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n///   match err {\n///     SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n///   }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//#region\n// These types are of workaround for the restriction that MoonBit do not support\n// generic type parameters of extern ffi\n\n///|\n#external\npriv type JSValue\n\n///|\nfn[T] JSValue::ofAny(array : T) -> JSValue = \"%identity\"\n\n///|\nfn[T] JSValue::toAny(self : JSValue) -> T = \"%identity\"\n\n///|\n#external\npriv type JSArray\n\n///|\nfn[T] JSArray::ofAnyArray(array : Array[T]) -> JSArray = \"%identity\"\n\n///|\nfn[T] JSArray::toAnyArray(self : JSArray) -> Array[T] = \"%identity\"\n\n///|\nextern \"js\" fn JSArray::set_length(self : JSArray, new_len : Int) -> Unit =\n  #| (arr, len) => { arr.length = len; }\n\n///|\nextern \"js\" fn JSArray::push(self : JSArray, value : JSValue) -> Unit =\n  #| (arr, val) => { arr.push(val); }\n\n///|\nextern \"js\" fn JSArray::pop(self : JSArray) -> JSValue =\n  #| (arr) => arr.pop()\n\n///|\nextern \"js\" fn JSArray::splice(\n  self : JSArray,\n  index : Int,\n  count : Int,\n) -> JSArray =\n  #| (arr, idx, cnt) => arr.splice(idx, cnt)\n\n///|\nextern \"js\" fn JSArray::splice1(\n  self : JSArray,\n  index : Int,\n  count : Int,\n  value : JSValue,\n) -> JSArray =\n  #| (arr, idx, cnt, val) => arr.splice(idx, cnt, val)\n\n///|\nextern \"js\" fn JSArray::fill(\n  self : JSArray,\n  value : JSValue,\n  start : Int,\n  end : Int,\n) -> Unit =\n  #| (arr, val, start, end) => arr.fill(val, start, end)\n\n//#endregion\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\n#external\ntype Array[T]\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Creates a new array.\npub fn[T] Array::new(capacity? : Int = 0) -> Array[T] {\n  ignore(capacity)\n  []\n}\n\n///|\n/// Returns the number of elements in the array.\npub fn[T] Array::length(self : Array[T]) -> Int = \"%fixedarray.length\"\n\n///|\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  JSArray::ofAnyArray(self).set_length(new_len)\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] = \"%identity\"\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// **NOTE**: This method does nothing on js platform.\n/// # Example\n///\n/// ```mbt\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 1)\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  ignore(self)\n  ignore(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// **NOTE**: This method does nothing on js platform.\n/// # Example\n///\n/// ```mbt\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   assert_eq(v.capacity(), 3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  ignore(self)\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt\n///   let v = []\n///   v.push(3)\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  JSArray::ofAnyArray(self).push(JSValue::ofAny(value))\n}\n\n///|\n/// Removes the last element from a array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt\n///   let v = [1, 2, 3]\n///   let vv = v.pop()\n///   assert_eq(vv, Some(3))\n///   assert_eq(v, [1, 2])\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  if self.length() == 0 {\n    None\n  } else {\n    let v = self.unsafe_pop()\n    Some(v)\n  }\n}\n\n///|\n/// Removes the last element from a array and returns it.\n///\n/// **NOTE** This method will not cause a panic, but it may result in undefined\n/// behavior on the JavaScript platform. Use with caution.\n///\n#internal(unsafe, \"Panic if the array is empty.\")\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  JSArray::ofAnyArray(self).pop().toAny()\n}\n\n///|\n/// Remove an element from the array at a given index.\n///\n/// Removes and returns the element at position index within the array, shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let vv = v.remove(1)\n///   assert_eq(vv, 4)\n///   assert_eq(v, [3, 5])\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.buffer()[index]\n  let _ = JSArray::ofAnyArray(self).splice(index, 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns a array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end else {\n    abort(\n      \"index out of bounds: the len is \\{self.length()} but the index is (\\{begin}, \\{end})\",\n    )\n  }\n  JSArray::ofAnyArray(self).splice(begin, end - begin).toAnyArray()\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   [3, 4, 5].insert(1, 6)\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let _ = JSArray::ofAnyArray(self).splice1(index, 0, JSValue::ofAny(value))\n\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitilized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  JSArray::ofAnyArray(self).set_length(new_len)\n}\n\n///|\n/// Fills an Array with a specified value.\n/// \n/// This method fills all or part of an Array with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```moonbit\n/// // Fill entire array\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.fill(0)\n/// inspect(arr, content=\"[0, 0, 0, 0, 0]\")\n/// \n/// // Fill from index 1 to 3 (exclusive)\n/// let arr2 = [1, 2, 3, 4, 5]\n/// arr2.fill(99, start=1, end=3)\n/// inspect(arr2, content=\"[1, 99, 99, 4, 5]\")\n/// \n/// // Fill from index 2 to end\n/// let arr3 = [\"a\", \"b\", \"c\", \"d\"]\n/// arr3.fill(\"x\", start=2)\n/// inspect(arr3, content=(\n///   #|[\"a\", \"b\", \"x\", \"x\"]\n/// ))\n/// ```\npub fn[A] Array::fill(\n  self : Array[A],\n  value : A,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let end = match end {\n    None => array_length\n    Some(e) => {\n      guard e >= 0 && e <= array_length\n      e\n    }\n  }\n  JSArray::ofAnyArray(self).fill(JSValue::ofAny(value), start, end)\n}\n"],"names":["Option$Some$0$","param0","Option$Some$1$","Option$Some$2$","Option$Some$3$","$64$moonbitlang$47$core$47$list$46$List$More$4$","param1","$64$Milky2018$47$selene$47$system$46$Schedule$Render","$64$Milky2018$47$selene$47$system$46$Schedule$UpdateFrame","$64$Milky2018$47$selene$47$system$46$Schedule$UpdateTime","$64$Milky2018$47$selene$47$sprite$46$SpriteType$Picture","$64$Milky2018$47$selene$47$sprite$46$SpriteType$Animation","$64$Milky2018$47$selene$47$sprite$46$SpriteType$Text","$64$Milky2018$47$selene$47$sprite$46$SpriteType$ColorRect","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$5$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$5$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$5$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$5$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Break$6$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Return$6$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$Error$6$","$64$moonbitlang$47$core$47$builtin$46$ForeachResult$JumpOuter$6$","Option$Some$7$","Option$Some$8$","Option$Some$9$","Option$Some$10$","Yoorkin$rabbit$45$tea$dom$$window","Option$Some$11$","KrystalRay$pokemoon_blackbox_test$$moonbit_test_driver_internal_get_file_name","Error$$to_string","*e","Milky2018$selene$system$$entity_generator","KrystalRay$pokemoon_blackbox_test$$moonbit_test_driver_internal_no_args_tests","Milky2018$selene$system$$all_entities","moonbitlang$core$abort$$abort$19$","msg","moonbitlang$core$ref$$Ref$new$10$","x","moonbitlang$core$set$$calc_grow_threshold","capacity","moonbitlang$core$set$$Set$new$46$inner$2$","*bind","moonbitlang$core$set$$Set$new$46$inner$8$","moonbitlang$core$set$$Set$add_entry_to_tail$2$","self","idx","entry","_tmp","moonbitlang$core$set$$Set$add_entry_to_tail$8$","moonbitlang$core$set$$Set$set_entry$2$","new_idx","*Some","*next","moonbitlang$core$set$$Set$set_entry$8$","moonbitlang$core$set$$Set$push_away$2$","psl","*curr_entry","moonbitlang$core$set$$Set$push_away$8$","moonbitlang$core$set$$Set$add_with_hash$2$","key","hash","*idx","*psl","moonbitlang$core$set$$Set$add_with_hash$8$","moonbitlang$core$set$$Set$grow$2$","old_head","new_capacity","*param","*x","*key","*hash","moonbitlang$core$set$$Set$grow$8$","moonbitlang$core$set$$Set$add$2$","moonbitlang$core$set$$Set$add$8$","moonbitlang$core$set$$Set$from_array$2$","arr","m","e","moonbitlang$core$builtin$$Logger$write_object$25$","obj","moonbitlang$core$builtin$$Show$output$26$","*x_2478","*x_2479","*Failure","**err_payload_2480","moonbitlang$core$builtin$$StringBuilder$new$46$inner","size_hint","moonbitlang$core$builtin$$StringBuilder$to_string","moonbitlang$core$builtin$$Logger$write_char$27$","ch","moonbitlang$core$string$$String$escape","buf","moonbitlang$core$array$$Array$op_get$25$","index","len","moonbitlang$core$builtin$$Logger$write_string$27$","str","moonbitlang$core$builtin$$Hasher$combine$25$","value","moonbitlang$core$builtin$$Hasher$combine$2$","moonbitlang$core$builtin$$Hasher$combine$8$","moonbitlang$core$builtin$$Hasher$avalanche","acc","moonbitlang$core$builtin$$Hasher$finalize","moonbitlang$core$builtin$$Hasher$new$46$inner","seed","moonbitlang$core$builtin$$Hash$hash$28$","*self","moonbitlang$core$builtin$$Hash$hash$22$","moonbitlang$core$builtin$$Hash$hash$23$","moonbitlang$core$builtin$$Show$to_string$0$","logger","moonbitlang$core$string$$String$charcode_at","moonbitlang$core$builtin$$output$46$inner$46$abs$124$1877","n","moonbitlang$core$builtin$$output$46$inner$46$write_digits$124$1879","*env","num","radix","num2","moonbitlang$core$int$$Int$output$46$inner","moonbitlang$core$int$$Int$output_size_hint$46$inner","moonbitlang$core$int$$Int$to_string$46$inner","moonbitlang$core$builtin$$Show$to_string$19$","moonbitlang$core$string$$String$substring$46$inner","start","end","moonbitlang$core$builtin$$Logger$write_substring$27$","moonbitlang$core$builtin$$to_hex_digit","i","moonbitlang$core$builtin$$output$46$flush_segment$124$1915","seg","moonbitlang$core$builtin$$Show$output$25$","code","c","moonbitlang$core$builtin$$Show$to_string$25$","moonbitlang$core$option$$Option$unwrap$20$","moonbitlang$core$option$$Option$unwrap$21$","moonbitlang$core$option$$Option$unwrap$29$","moonbitlang$core$builtin$$calc_grow_threshold","moonbitlang$core$int$$Int$next_power_of_two","moonbitlang$core$builtin$$Map$new$46$inner$17$","moonbitlang$core$builtin$$Map$new$46$inner$5$","moonbitlang$core$builtin$$Map$new$46$inner$9$","moonbitlang$core$builtin$$Map$new$46$inner$1$","moonbitlang$core$builtin$$Map$new$46$inner$3$","moonbitlang$core$builtin$$Map$new$46$inner$4$","moonbitlang$core$builtin$$Map$new$46$inner$11$","moonbitlang$core$builtin$$Map$new$46$inner$14$","moonbitlang$core$builtin$$Map$new$46$inner$12$","moonbitlang$core$builtin$$Map$new$46$inner$6$","moonbitlang$core$builtin$$Map$new$46$inner$7$","moonbitlang$core$builtin$$Map$new$46$inner$13$","moonbitlang$core$builtin$$Map$new$46$inner$16$","moonbitlang$core$array$$Array$each$30$","f","*len","*i","v","moonbitlang$core$array$$Array$each$24$","moonbitlang$core$builtin$$Map$add_entry_to_tail$1$","moonbitlang$core$builtin$$Map$set_entry$1$","moonbitlang$core$builtin$$Map$push_away$1$","moonbitlang$core$builtin$$Map$set_with_hash$1$","moonbitlang$core$builtin$$Map$grow$1$","*value","moonbitlang$core$builtin$$Map$set$1$","moonbitlang$core$builtin$$Map$from_array$1$","moonbitlang$core$builtin$$Map$get$31$","*entry","moonbitlang$core$builtin$$Map$get$1$","moonbitlang$core$builtin$$rotl","r","moonbitlang$core$builtin$$Hasher$consume4","input","moonbitlang$core$builtin$$Hasher$combine_uint","moonbitlang$core$builtin$$Hasher$combine_int","moonbitlang$core$builtin$$Hasher$combine_string","*end883","moonbitlang$core$builtin$$Hash$hash_combine$25$","hasher","moonbitlang$core$builtin$$Hash$hash$19$","moonbitlang$core$builtin$$Hash$hash_combine$32$","moonbitlang$core$builtin$$println$25$","moonbitlang$core$array$$Array$new$46$inner$15$","moonbitlang$core$array$$Array$new$46$inner$18$","moonbitlang$core$array$$Array$is_empty$25$","Milky2018$selene$math$$Vec2D$zero","moonbitlang$core$builtin$$Eq$op_equal$8$","*x_137","*x_138","moonbitlang$core$builtin$$Hash$hash_combine$8$","*x_129","*x_130","moonbitlang$core$builtin$$Eq$op_equal$2$","*x_125","*x_126","moonbitlang$core$builtin$$Hash$hash_combine$2$","*x_117","*x_118","Milky2018$selene$system$$Entity$new","entity","Milky2018$selene$collision$$QuadTree$new","position","size","depth","KrystalRay$pokemoon_blackbox_test$$moonbit_test_driver_internal_execute","filename","file_filter","index_filter","filtered_test","index_func_map","*index_func_map","test_name","message","item","*item","func","attrs","name","*try_err","*ok","*err","*InspectError","*SnapshotError","file_name","KrystalRay$pokemoon_blackbox_test$$moonbit_test_driver_finish"],"mappings":"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"}