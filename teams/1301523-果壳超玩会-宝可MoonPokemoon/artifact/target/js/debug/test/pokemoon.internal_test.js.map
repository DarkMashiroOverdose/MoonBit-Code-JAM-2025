{"version":3,"sources":["/Users/kelei/opensource/selene-pokemoon/pokemoon/src/__generated_driver_for_internal_test.mbt","/Users/kelei/.moon/lib/core/abort/abort.mbt","/Users/kelei/.moon/lib/core/builtin/traits.mbt","/Users/kelei/.moon/lib/core/builtin/fixedarray_block.mbt","/Users/kelei/.moon/lib/core/builtin/uninitialized_array.mbt","/Users/kelei/.moon/lib/core/builtin/stringbuilder_concat.mbt","/Users/kelei/.moon/lib/core/builtin/op.mbt","/Users/kelei/.moon/lib/core/builtin/show.mbt","/Users/kelei/.moon/lib/core/builtin/array.mbt","/Users/kelei/.moon/lib/core/builtin/hasher.mbt","/Users/kelei/.moon/lib/core/builtin/deprecated.mbt","/Users/kelei/.moon/lib/core/builtin/output.mbt","/Users/kelei/.moon/lib/core/builtin/to_string.mbt","/Users/kelei/.moon/lib/core/builtin/assert.mbt","/Users/kelei/.moon/lib/core/builtin/failure.mbt","/Users/kelei/.moon/lib/core/builtin/string.mbt","/Users/kelei/.moon/lib/core/builtin/option.mbt","/Users/kelei/.moon/lib/core/builtin/linked_hash_map.mbt","/Users/kelei/.moon/lib/core/builtin/int.mbt","/Users/kelei/.moon/lib/core/builtin/console.mbt","/Users/kelei/.moon/lib/core/builtin/autoloc.mbt","/Users/kelei/opensource/selene-pokemoon/pokemoon/src/pokemon_data.mbt"],"sourcesContent":[null,"// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  op_equal(Self, Self) -> Bool\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit\n  write_substring(Self, String, Int, Int) -> Unit\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n// Default implementation for `Show::to_string`, uses a `Buffer`\n///|\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Copies a slice of elements from one fixed array to another.\n///\n/// This function copies `len` elements from `src` starting at `src_offset` to `dst` starting at `dst_offset`.\n/// The arrays may overlap, in which case the copy is performed in a way that preserves the data.\n///\n/// # Example\n/// ```mbt\n///   let src = FixedArray::from_array([1, 2, 3, 4, 5])\n///   let dst = FixedArray::from_array([0, 0, 0, 0, 0])\n///   FixedArray::unsafe_blit(dst, 0, src, 0, 3)\n///   assert_eq(dst, FixedArray::from_array([1, 2, 3, 0, 0]))\n/// ```\n///\n/// The behavior is undefined and platform-specific if:\n/// - `len < 0`\n/// - `src_offset < 0`\n/// - `dst_offset < 0`\n/// - `dst_offset + len > dst.length()`\n/// - `src_offset + len > src.length()`\n///\n#intrinsic(\"%fixedarray.copy\")\n#coverage.skip\npub fn[A] FixedArray::unsafe_blit(\n  dst : FixedArray[A],\n  dst_offset : Int,\n  src : FixedArray[A],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  if physical_equal(dst, src) && dst_offset < src_offset {\n    for i in 0..<len {\n      dst[dst_offset + i] = src[src_offset + i]\n    }\n  } else {\n    for i = len - 1; i >= 0; i = i - 1 {\n      dst[dst_offset + i] = src[src_offset + i]\n    }\n  }\n}\n\n///|\n/// This is the same as `unsafe_blit`, but it is used when the source array is\n/// FixedArray[T] instead of UninitializedArray[T].\n#intrinsic(\"%fixedarray.copy\")\n#coverage.skip\nfn[T] UninitializedArray::unsafe_blit_fixed(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : FixedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  for i = len - 1; i >= 0; i = i - 1 {\n    dst[dst_offset + i] = src[src_offset + i]\n  }\n}\n\n///|\n/// Copies a sequence of elements from the source fixed array to a destination\n/// fixed array. The arrays may overlap, in which case the copy is performed in a\n/// way that preserves the data.\n///\n/// Parameters:\n///\n/// * `self` : The source fixed array from which elements will be copied.\n/// * `dst` : The destination fixed array where elements will be copied to.\n/// * `len` : The number of elements to copy.\n/// * `src_offset` : The starting position in the source array. Defaults to 0.\n/// * `dst_offset` : The starting position in the destination array. Defaults to\n/// 0.\n///\n/// Throws a panic if:\n///\n/// * `src_offset + len` exceeds the length of the source array\n/// * `dst_offset + len` exceeds the length of the destination array\n///\n/// Example:\n///\n/// ```moonbit\n///   let src = FixedArray::make(5, 1)\n///   let dst = FixedArray::make(5, 0)\n///   src.blit_to(dst, len=3, src_offset=1, dst_offset=2)\n///   inspect(dst, content=\"[0, 0, 1, 1, 1]\")\n/// ```\npub fn[A] FixedArray::blit_to(\n  self : FixedArray[A],\n  dst : FixedArray[A],\n  len~ : Int,\n  src_offset? : Int = 0,\n  dst_offset? : Int = 0,\n) -> Unit {\n  guard dst_offset >= 0 &&\n    src_offset >= 0 &&\n    dst_offset + len <= dst.length() &&\n    src_offset + len <= self.length() else {\n    abort(\n      \"bounds check failed: dst_offset = \\{dst_offset}, src_offset = \\{src_offset}, len = \\{len}, dst.length = \\{dst.length()}, self.length = \\{self.length()}\",\n    )\n  }\n  FixedArray::unsafe_blit(dst, dst_offset, self, src_offset, len)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\npub fn[T] UninitializedArray::op_get(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\npub fn[T] UninitializedArray::op_set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\npub fn[T] UninitializedArray::op_as_view(\n  self : UninitializedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  let UninitializedArray(self) = self\n  self.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"op_as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic op_as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic op_as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n\n///|\n#intrinsic(\"%fixedarray.fill\")\n#cfg(not(target=\"js\"))\nfn[T] UninitializedArray::unchecked_fill(\n  self : UninitializedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder(Ref[String])\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  ignore(size_hint)\n  { val: \"\" }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.val == \"\"\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.val += str\n}\n\n///|\n#intrinsic(\"%char.to_string\")\nfn char_to_string(char : Char) -> String {\n  [char]\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.val += char_to_string(ch)\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sb = StringBuilder::new()\n///   sb.write_substring(\"Hello, world!\", 0, 5)\n///   assert_eq(sb.to_string(), \"Hello\")\n/// ```\npub impl Logger for StringBuilder with write_substring(\n  self : StringBuilder,\n  str : String,\n  start : Int,\n  len : Int,\n) -> Unit {\n  self.val += str.substring(start~, end=start + len)\n}\n\n///|\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(self.val)\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.val\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.val = \"\"\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#coverage.skip\npub fn[T : Compare] op_lt(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_neg()\n}\n\n///|\n#coverage.skip\npub fn[T : Compare] op_gt(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_pos()\n}\n\n///|\n#coverage.skip\npub fn[T : Compare] op_le(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_non_pos()\n}\n\n///|\n#coverage.skip\npub fn[T : Compare] op_ge(self_ : T, other : T) -> Bool {\n  self_.compare(other).is_non_neg()\n}\n\n///|\n#coverage.skip\npub fn[T : Eq] op_notequal(x : T, y : T) -> Bool {\n  !(x == y)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  self.output(logger)\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  self.to_int().output(logger)\n}\n\n///|\nfn to_hex_digit(i : Int) -> Char {\n  if i < 10 {\n    (i + '0').unsafe_to_char()\n  } else {\n    (i + 'a' - 10).unsafe_to_char()\n  }\n}\n\n///|\ntest \"to_hex_digit\" {\n  for i in 0..<10 {\n    guard to_hex_digit(i) == ('0'.to_int() + i).unsafe_to_char() else {\n      fail(\"to_hex_digit(\\{i}) does not match\")\n    }\n  }\n  for i in 10..<16 {\n    guard to_hex_digit(i) == ('a'.to_int() + (i - 10)).unsafe_to_char() else {\n      fail(\"to_hex_digit(\\{i}) does not match\")\n    }\n  }\n}\n\n///|\npub impl Show for Bytes with output(self, logger) {\n  logger.write_string(\"b\\\"\")\n  for b in self {\n    let byte = b.to_int()\n    logger\n    ..write_string(\"\\\\x\")\n    ..write_char(to_hex_digit(byte / 16))\n    ..write_char(to_hex_digit(byte % 16))\n  }\n  logger.write_string(\"\\\"\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_char(to_hex_digit(code / 16))\n          ..write_char(to_hex_digit(code % 16))\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for Ref[X] with output(self, logger) {\n  logger..write_string(\"{val: \")..write_object(self.val)..write_string(\"}\")\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```moonbit\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.get\")\npub fn[T] Array::op_get(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\nfn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// ```\n///\n#intrinsic(\"%array.set\")\npub fn[T] Array::op_set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// ```\npub impl[T : Eq] Eq for Array[T] with op_equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// ```\npub impl[T] Add for Array[T] with op_add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// ```\npub fn[T] Array::append(self : Array[T], other : Array[T]) -> Unit {\n  other.blit_to(\n    self,\n    len=other.length(),\n    src_offset=0,\n    dst_offset=self.length(),\n  )\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each((x) => { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each((x) => { sum = sum - x })\n///   @json.inspect(sum, content=-12)\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => { sum = sum + x + i })\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```moonbit\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => {sum = sum + x + i})\n///   inspect(sum, content=\"15\")\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.map((x) => {x + 1})\n///   assert_eq(v2, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.map_inplace((x) => {x + 1})\n///   assert_eq(v, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T] Array::map_inplace(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => {x + i})\n///   assert_eq(v2, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.mapi_inplace((i, x) => {x + i})\n///   assert_eq(v, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T] Array::mapi_inplace(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter((x) => { x % 2 == 0 })\n///   inspect(evens, content=\"[2, 4]\")\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Tests whether the array is sorted in ascending order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be tested.\n/// * `T` : The type of elements in the array. Must implement the `Compare`\n/// trait.\n///\n/// Returns a boolean value indicating whether the array is sorted in ascending\n/// order:\n///\n/// * `true` if the array is empty, contains only one element, or all elements\n/// are in ascending order.\n/// * `false` if any element is greater than the element that follows it.\n///\n/// Example:\n///\n/// ```moonbit\n///   let ascending = [1, 2, 3, 4, 5]\n///   let descending = [5, 4, 3, 2, 1]\n///   let unsorted = [1, 3, 2, 4, 5]\n///   inspect(ascending.is_sorted(), content=\"true\")\n///   inspect(descending.is_sorted(), content=\"false\")\n///   inspect(unsorted.is_sorted(), content=\"false\")\n/// ```\npub fn[T : Compare] Array::is_sorted(self : Array[T]) -> Bool {\n  for i = 1 {\n    if i >= self.length() {\n      break true\n    }\n    if self[i - 1] > self[i] {\n      break false\n    }\n    continue i + 1\n  }\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_inplace()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///\n///   let arr : Array[Int] = []\n///   arr.rev_inplace()\n///   inspect(arr, content=\"[]\")\n/// ```\npub fn[T] Array::rev_inplace(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let (v1, v2) = v.split_at(1)\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// ```\n/// TODO: perf could be optimized\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  if suffix.length() > self.length() {\n    return false\n  }\n  for i in 0..<suffix.length() {\n    if self.unsafe_get(self.length() - suffix.length() + i) !=\n      suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  for i, v in self {\n    if v == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by((x) => { x == 3 }) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// ```\n#locals(f)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by((x) => {\n///     x.compare(3)\n///   })\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by((x) => {\n///     x.compare(4)\n///   })\n///   inspect(find_4, content=\"Err(2)\")\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\n#locals(cmp)\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain((x) => { x % 2 == 0 })\n///   inspect(arr, content=\"[2, 4]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.retain((x) => { x > 10 })\n///   inspect(arr, content=\"[]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens a array of arrays into a array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create a array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#locals(f)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#locals(f)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if((x) => { x % 2 == 0 })\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let v = []\n  let indices = []\n  for i in 0..<self.length() {\n    if f(self[i]) {\n      v.push(self[i])\n      indices.push(i)\n    }\n  }\n  for i in 0..<indices.length() {\n    self.remove(indices[i] - i) |> ignore\n  }\n  v\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[Array[T]] {\n  guard size > 0\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = Array::new(capacity=size)\n    for j = 0; j < size && i < self.length(); j = j + 1 {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n  }\n  chunks\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```moonbit\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => { x <= y })\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => { x <= y }), content=\"[]\")\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    chunk.push(self[i])\n    i = i + 1\n    while i < self.length() && pred(self[i - 1], self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n  }\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  let windows = Array::new(capacity=len)\n  for i in 0..<len {\n    windows.push(self[i:i + size])\n  }\n  windows\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split((x) => { x == 0 }), content=\"[[1], [2], [3], [4]]\")\n///\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split((x) => { x == 0 }), content=\"[[], [1], [], [2]]\")\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each((x) => { sum = sum + x })\n///   inspect(sum, content=\"6\")\n/// ```\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  Iter::new(yield_ => for v in self {\n    guard yield_(v) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each((x) => { result.push(x) })\n///   inspect(result, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  Iter::new(yield_ => for i = self.length() - 1; i >= 0; i = i - 1 {\n    guard yield_(self.unsafe_get(i)) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => { sum = sum + i + x })\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// ```\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  Iter2::new(yield_ => for i, v in self {\n    guard yield_(i, v) is IterContinue else { break IterEnd }\n  } else {\n    IterContinue\n  })\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.truncate(3)\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```moonbit\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.retain_map(fn(x) {\n///   if x % 2 == 0 {\n///     Some(x * 2)\n///   } else {\n///     None\n///   }\n/// })\n/// inspect(arr,content = \"[4, 8]\")\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let h1 = Hasher::new() // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// ```\npub fn Hasher::new(seed? : Int = 0) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_float(3.14)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// ```\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\n/// Implements the `Hash` trait for integer values using a combination of shifts\n/// and multiplications to produce a well-distributed hash value. Based on the\n/// hash algorithm from hash-prospector\n/// (https://github.com/skeeto/hash-prospector).\n///\n/// Parameters:\n///\n/// * `integer` : The integer value to be hashed. The value will be reinterpreted\n/// as an unsigned integer before hashing to ensure consistent behavior across\n/// positive and negative values.\n///\n/// Returns a 32-bit hash value derived from the input integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x = 42\n///   inspect(Hash::hash(x), content=\"-1704501356\")\n///   let y = -42\n///   inspect(Hash::hash(y), content=\"1617647962\")\n/// ```\npub impl Hash for Int with hash(self) {\n  let self = self.reinterpret_as_uint()\n  let mut x = self ^ (self >> 17)\n  x = x * 0xed5ad4bb\n  x = x ^ (x >> 11)\n  x = x * 0xac4c1b51\n  x = x ^ (x >> 15)\n  x = x * 0x31848bab\n  x = x ^ (x >> 14)\n  x.reinterpret_as_int()\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new()\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```moonbit\n///   let hasher = Hasher::new()\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new()\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates an iterator that iterates over a range of Int with default step 1.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Int::upto(self : Int, end : Int, inclusive? : Bool = false) -> Iter[Int] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of UInt with default step 1U.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of UInt from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn UInt::upto(\n  self : UInt,\n  end : UInt,\n  inclusive? : Bool = false,\n) -> Iter[UInt] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of UInt64 with default step 1UL.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of UInt64 from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn UInt64::upto(\n  self : UInt64,\n  end : UInt64,\n  inclusive? : Bool = false,\n) -> Iter[UInt64] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Int64 with default step 1L.\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Int64 from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Int64::upto(\n  self : Int64,\n  end : Int64,\n  inclusive? : Bool = false,\n) -> Iter[Int64] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Float with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Float from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Float::upto(\n  self : Float,\n  end : Float,\n  inclusive? : Bool = false,\n) -> Iter[Float] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Creates an iterator that iterates over a range of Double with default step 1.0 .\n///\n/// # Arguments\n///\n/// * `start` - The starting value of the range (inclusive).\n/// * `end` - The ending value of the range (exclusive).\n/// * `inclusive` - Whether the ending value is inclusive (default false).\n///\n/// # Returns\n///\n/// Returns an iterator that iterates over the range of Double from `start` to `end - 1`.\n#deprecated(\"Use `..<` in for loop or `until` method instead\")\n#coverage.skip\npub fn Double::upto(\n  self : Double,\n  end : Double,\n  inclusive? : Bool = false,\n) -> Iter[Double] {\n  yield_ => {\n    let mut i = self\n    while i < end || (inclusive && i == end) {\n      if yield_(i) == IterEnd {\n        break IterEnd\n      }\n      if i == end {\n        break IterContinue\n      }\n      i += 1\n    } else {\n      IterContinue\n    }\n  }\n}\n\n///|\n/// Searches the array for the first element that satisfies the predicate\n/// function.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element satisfies the search condition.\n///\n/// Returns the index of the first element that satisfies the predicate, or\n/// `None` if no such element is found.\n///\n/// Example:\n///\n/// ```moonbit\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.search_by((x) => { x > 3 }), content=\"Some(3)\")\n///   inspect(arr.search_by((x) => { x > 10 }), content=\"None\")\n/// ```\n///\n#deprecated(\"Use `search_by` instead.\")\n#coverage.skip\npub fn[T] Array::find_index(self : Array[T], f : (T) -> Bool) -> Int? {\n  self.search_by(f)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#deprecated(\"Use `fold` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_left(\n  self : Array[T],\n  f : (U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.fold(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// ```\n#deprecated(\"Use `rev_fold` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_right(\n  self : Array[T],\n  f : (U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.rev_fold(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#deprecated(\"Use `foldi` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_lefti(\n  self : Array[T],\n  f : (Int, U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.foldi(init~, f)\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```moonbit\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// ```\n#deprecated(\"Use `rev_foldi` instead.\")\n#coverage.skip\npub fn[T, U] Array::fold_righti(\n  self : Array[T],\n  f : (Int, U, T) -> U raise?,\n  init~ : U,\n) -> U raise? {\n  self.rev_foldi(init~, f)\n}\n\n///|\n#deprecated(\"Use `unsafe_pop` instead\")\n#coverage.skip\npub fn[T] Array::pop_exn(self : Array[T]) -> T {\n  self.unsafe_pop()\n}\n\n///|\n/// Creates a byte sequence from a UTF-16 encoded string. Each character in the\n/// string is encoded as a pair of bytes in little-endian order.\n///\n/// Parameters:\n///\n/// * `string` : The input string to be converted to a byte sequence.\n///\n/// Returns a new byte sequence containing the UTF-16LE encoded representation of\n/// the input string.\n///\n/// Example:\n///\n/// ```moonbit\n///   let bytes = \"ABC\".to_bytes()\n///   inspect(bytes, content=\"b\\\"\\\\x41\\\\x00\\\\x42\\\\x00\\\\x43\\\\x00\\\"\")\n/// ```\n#deprecated(\"Use `str.to_bytes()` instead\")\npub fn Bytes::of_string(str : String) -> Bytes {\n  FixedArray::make(str.length() * 2, Byte::default())\n  ..blit_from_string(0, str, 0, str.length())\n  .unsafe_reinterpret_as_bytes()\n}\n\n///|\n#deprecated(\"Bytes are immutable. Use `FixedArray::blit_from_bytes` if it's really necessary.\")\npub fn Bytes::copy(self : Bytes) -> Bytes {\n  Bytes::makei(self.length(), i => self[i])\n}\n\n///|\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the bitwise left shift operation.\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Byte::lsl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// bits.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to be shifted.\n/// - `count` : The number of bits to shift the `value` to the right.\n///\n/// Returns the result of the logical shift right operation as a `Byte`.\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Byte::lsr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n\n///|\n/// Prints and returns the value of a given expression for quick and dirty debugging.\n#callsite(autofill(loc))\n#deprecated(\"This function is for debugging only and should not be used in production\")\npub fn[T] dump(t : T, name? : String, loc~ : SourceLoc) -> T {\n  let name = match name {\n    Some(name) => name\n    None => \"\"\n  }\n  println(\"dump(\\{name}@\\{loc}) = \\{any_to_string(t)}\")\n  t\n}\n\n///|\n/// Returns the Unicode code point at the given index.\n///\n/// This method counts Unicode code points (characters) rather than UTF-16 code units.\n/// It properly handles surrogate pairs to return the correct Unicode character.\n///\n/// # Examples\n///\n/// ```mbt\n/// let s = \"Hello🤣\"\n/// inspect(s.get_char(0).unwrap(), content=\"H\")\n/// inspect(s.get_char(5).unwrap(), content=\"🤣\")\n/// ```\n///\n/// # Panics\n///\n/// Panics if:\n/// - The index is out of bounds\n/// - The string contains an invalid surrogate pair\n#deprecated(\"The index will be changed to utf16 index. If you want to access n-th character, use `str.iter().nth(n).unwrap()` instead.\")\npub fn String::codepoint_at(self : String, index : Int) -> Char {\n  let charcode_len = self.length()\n  guard index >= 0 && index < charcode_len else { abort(\"index out of bounds\") }\n  for char_count = 0, utf16_offset = 0\n      char_count < charcode_len && utf16_offset < index\n      char_count = char_count + 1, utf16_offset = utf16_offset + 1 {\n    let c1 = self.unsafe_charcode_at(char_count)\n    if c1.is_leading_surrogate() && char_count + 1 < charcode_len {\n      let c2 = self.unsafe_charcode_at(char_count + 1)\n      if c2.is_trailing_surrogate() {\n        continue char_count + 2, utf16_offset + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    guard utf16_offset == index && char_count < charcode_len else {\n      abort(\"index out of bounds\")\n    }\n    let c1 = self.unsafe_charcode_at(char_count)\n    if c1.is_leading_surrogate() && char_count + 1 < charcode_len {\n      let c2 = self.unsafe_charcode_at(char_count + 1)\n      if c2.is_trailing_surrogate() {\n        code_point_of_surrogate_pair(c1, c2)\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    } else {\n      c1.unsafe_to_char()\n    }\n  }\n}\n\n///|\n#deprecated(\"Use `char_length` instead.\")\npub fn String::codepoint_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  self.char_length(start_offset~, end_offset?)\n}\n\n///|\n#deprecated(\"Use `s[i]` instead\")\npub fn String::charcode_at(self : String, index : Int) -> Int {\n  self[index]\n}\n\n///|\n/// Returns the Unicode code point at the given index without bounds checking.\n#deprecated(\"Use `s.get_char(i).unwrap()` instead\")\npub fn String::unsafe_char_at(self : String, index : Int) -> Char {\n  let c1 = self.unsafe_charcode_at(index)\n  if c1.is_leading_surrogate() {\n    let c2 = self.unsafe_charcode_at(index + 1)\n    code_point_of_surrogate_pair(c1, c2)\n  } else {\n    c1.unsafe_to_char()\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn Int64::output(self : Int64, logger : &Logger, radix? : Int = 10) -> Unit {\n  fn abs(n : Int64) -> Int64 {\n    if n < 0L {\n      0L - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0L {\n    logger.write_char('-')\n  }\n  let radix : Int64 = radix.to_int64()\n  fn write_digits(num : Int64) {\n    let num2 = num / radix\n    if num2 != 0L {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at(abs(num % radix).to_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn Int::output(self : Int, logger : &Logger, radix? : Int = 10) -> Unit {\n  fn abs(n : Int) -> Int {\n    if n < 0 {\n      0 - n\n    } else {\n      n\n    }\n  }\n\n  if self < 0 {\n    logger.write_char('-')\n  }\n  fn write_digits(num : Int) {\n    let num2 = num / radix\n    if num2 != 0 {\n      write_digits(num2)\n    }\n    logger.write_char(ALPHABET.charcode_at(abs(num % radix)).unsafe_to_char())\n  }\n\n  write_digits(abs(self))\n}\n\n///|\nfn UInt::output(self : UInt, logger : &Logger, radix? : Int = 10) -> Unit {\n  let radix : UInt = radix.reinterpret_as_uint()\n  fn write_digits(num : UInt) {\n    let num2 = num / radix\n    if num2 != 0U {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at((num % radix).reinterpret_as_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn UInt64::output(self : UInt64, logger : &Logger, radix? : Int = 10) -> Unit {\n  let radix : UInt64 = radix.to_uint64()\n  fn write_digits(num : UInt64) {\n    let num2 = num / radix\n    if num2 != 0UL {\n      write_digits(num2)\n    }\n    logger.write_char(\n      ALPHABET.charcode_at((num % radix).to_int()).unsafe_to_char(),\n    )\n  }\n\n  write_digits(self)\n}\n\n///|\nfn Int64::output_size_hint(radix? : Int = 10) -> Int {\n  match radix {\n    2..<7 => 70 // max length is 64, 70 is enough\n    8..<15 => 30 // max length is 23, 30 is enough\n    16..=36 => 20 // max length is 17, 20 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn Int::output_size_hint(radix? : Int = 10) -> Int {\n  match radix {\n    2..<7 => 36 // max length is 32, 36 is enough\n    8..<15 => 18 // max length is 12, 18 is enough\n    16..=36 => 10 // max length is 8, 10 is enough\n    _ => abort(\"radix must be between 2 and 36\")\n  }\n}\n\n///|\nfn UInt::output_size_hint(radix? : Int = 10) -> Int {\n  Int::output_size_hint(radix~)\n}\n\n///|\nfn UInt64::output_size_hint(radix? : Int = 10) -> Int {\n  Int64::output_size_hint(radix~)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=Int::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for Int with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  let buf = StringBuilder::new(size_hint=UInt64::output_size_hint(radix~))\n  self.output(buf, radix~)\n  buf.to_string()\n}\n\n///|\npub impl Show for UInt64 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn Int16::to_string(self : Int16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for Int16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n///|\npub impl Show for UInt16 with to_string(self) {\n  self.to_string(radix=10)\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"to_string with radix\" {\n  // Binary\n  inspect((0).to_string(radix=2), content=\"0\")\n  inspect((1).to_string(radix=2), content=\"1\")\n  inspect((2).to_string(radix=2), content=\"10\")\n  inspect((255).to_string(radix=2), content=\"11111111\")\n  inspect((-255).to_string(radix=2), content=\"-11111111\")\n\n  // Octal\n  inspect((0).to_string(radix=8), content=\"0\")\n  inspect((8).to_string(radix=8), content=\"10\")\n  inspect((64).to_string(radix=8), content=\"100\")\n  inspect((-64).to_string(radix=8), content=\"-100\")\n\n  // Decimal\n  inspect((0).to_string(radix=10), content=\"0\")\n  inspect((123).to_string(radix=10), content=\"123\")\n  inspect((-123).to_string(radix=10), content=\"-123\")\n  inspect(\n    0x7fff_ffff_ffff_ffffL.to_string(radix=10),\n    content=\"9223372036854775807\",\n  )\n  inspect(\n    0x8000_0000_0000_0000L.to_string(radix=10),\n    content=\"-9223372036854775808\",\n  )\n\n  // Hexadecimal\n  inspect((0).to_string(radix=16), content=\"0\")\n  inspect((0x11).to_string(radix=16), content=\"11\")\n  inspect((0x15ef).to_string(radix=16), content=\"15ef\")\n  inspect((-0xabcd).to_string(radix=16), content=\"-abcd\")\n  inspect(\n    (1.0 : Float).reinterpret_as_int().to_string(radix=16),\n    content=\"3f800000\",\n  )\n\n  // UInt\n  inspect(0U.to_string(radix=16), content=\"0\")\n  inspect(0x1AU.to_string(radix=16), content=\"1a\")\n  inspect(0xabcdU.to_string(radix=16), content=\"abcd\")\n  inspect(\n    (-2.0 : Float).reinterpret_as_uint().to_string(radix=16),\n    content=\"c0000000\",\n  )\n  inspect((-1).reinterpret_as_uint().to_string(radix=16), content=\"ffffffff\")\n\n  // Int64\n  inspect(0L.to_string(radix=16), content=\"0\")\n  inspect(0x2fL.to_string(radix=16), content=\"2f\")\n  inspect(0xf0aeL.to_string(radix=16), content=\"f0ae\")\n  inspect((-0x1234eacbL).to_string(radix=16), content=\"-1234eacb\")\n  inspect(\n    1.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"3ff0000000000000\",\n  )\n  inspect(0b101L.to_string(radix=2), content=\"101\")\n  inspect(0o17L.to_string(radix=8), content=\"17\")\n\n  // UInt64\n  inspect(0UL.to_string(radix=16), content=\"0\")\n  inspect(0x11UL.to_string(radix=16), content=\"11\")\n  inspect(0x12bdUL.to_string(radix=16), content=\"12bd\")\n  inspect(\n    (-1L).reinterpret_as_uint64().to_string(radix=16),\n    content=\"ffffffffffffffff\",\n  )\n  inspect(\n    2.0.reinterpret_as_uint64().to_string(radix=16),\n    content=\"4000000000000000\",\n  )\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T : Show] debug_string(t : T) -> String {\n  let buf = StringBuilder::new(size_hint=50)\n  t.output(buf)\n  buf.to_string()\n}\n\n///|\n/// Asserts that two values are equal. If they are not equal, raises a failure\n/// with a message containing the source location and the values being compared.\n///\n/// Parameters:\n///\n/// * `a` : First value to compare.\n/// * `b` : Second value to compare.\n/// * `loc` : Source location information to include in failure messages. This is\n/// usually automatically provided by the compiler.\n///\n/// Throws a `Failure` error if the values are not equal, with a message showing\n/// the location of the failing assertion and the actual values that were\n/// compared.\n///\n/// Example:\n///\n/// ```moonbit\n///   assert_eq(1, 1)\n///   assert_eq(\"hello\", \"hello\")\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if a != b {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} != \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that two values of the same type are not equal. If the values are\n/// equal, raises a failure with a detailed error message including the source\n/// location and string representation of both values.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `location` : Source location information for error reporting. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error if the values are equal. The error message includes\n/// the source location and string representations of both values.\n///\n/// Example:\n///\n/// ```moonbit\n///   assert_not_eq(1, 2) // Passes\n///\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_not_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if !(a != b) {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} == \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that the given boolean value is true. Throws an error with source\n/// location information if the assertion fails.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean value to be checked.\n/// * `location` : The source location where the assertion is made. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error with a descriptive message including the source\n/// location if the condition is false.\n///\n/// Example:\n///\n/// ```moonbit\n///   assert_true(true)\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_true(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if !x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not true\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Tests whether a boolean condition is false, throwing an error if the\n/// condition is true.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean condition to test.\n/// * `location` : The source location where the assertion is made. Used in error\n/// messages.\n///\n/// Throws a `Failure` error if the condition is true. The error message includes\n/// the source location and the value that was expected to be false.\n///\n/// Example:\n///\n/// ```moonbit\n///   assert_false(false)\n///   assert_false(1 > 2)\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_false(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not false\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `suberror` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```moonbit\n/// let err : Failure = Failure(\"Test assertion failed\")\n/// match err {\n///   Failure(msg) => inspect(msg, content=\"Test assertion failed\")\n/// }\n/// @json.inspect(err, content=[\"Failure\", \"Test assertion failed\"])\n/// ```\npub(all) suberror Failure String derive(ToJson(style=\"flat\"), Show)\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise Failure {\n  raise Failure(\"\\{loc} FAILED: \\{msg}\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n///|\n/// Create new string of `length`, where each character is `value`\n///\n/// ```mbt\n///   assert_eq(String::make(5,'S'), \"SSSSS\")\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  guard length >= 0 else { abort(\"invalid length\") }\n  if value.to_int() <= 0xFFFF {\n    unsafe_make_string(length, value)\n  } else {\n    let buf = StringBuilder::new(size_hint=2 * length)\n    for _ in 0..<length {\n      buf.write_char(value)\n    }\n    buf.to_string()\n  }\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  ((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000).unsafe_to_char()\n}\n\n///|\n/// Returns the number of Unicode code points (characters) in the string.\n///\n/// This method counts actual Unicode characters, properly handling surrogate pairs\n/// that represent single characters like emojis. For the raw UTF-16 code unit count,\n/// use `length()` instead.\n///\n/// # Examples\n///\n/// ```mbt\n///   let s = \"Hello🤣\";\n///   inspect(s.char_length(), content = \"6\"); // 6 actual characters\n///   inspect(s.length(), content = \"7\");  // 5 ASCII chars + 2 surrogate pairs\n/// ```\npub fn String::char_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"invalid start or end index for String::codepoint_length\")\n  }\n  for utf16_index = start_offset, char_count = 0\n      utf16_index < end_offset\n      utf16_index = utf16_index + 1, char_count = char_count + 1 {\n    let c1 = self.unsafe_charcode_at(utf16_index)\n    if c1.is_leading_surrogate() && utf16_index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(utf16_index + 1)\n      if c2.is_trailing_surrogate() {\n        continue utf16_index + 2, char_count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    char_count\n  }\n}\n\n///|\n#intrinsic(\"%string.substring\")\nfn unsafe_substring(str : String, start : Int, end : Int) -> String {\n  let len = end - start\n  let bytes = FixedArray::make(len * 2, Byte::default())\n  bytes.blit_from_string(0, str, start, len)\n  bytes.unsafe_reinterpret_as_bytes().to_unchecked_string()\n}\n\n///|\n/// Returns a new string containing characters from the original string starting\n/// at `start` index up to (but not including) `end` index.\n///\n/// Parameters:\n///\n/// * `string` : The source string from which to extract the substring.\n/// * `start` : The starting index of the substring (inclusive). Defaults to 0.\n/// * `end` : The ending index of the substring (exclusive). Defaults to the\n/// length of the string.\n///\n/// Returns a new string containing the specified substring.\n///\n/// Example:\n///\n/// ```moonbit\n///   let s = \"Hello world\"\n///   inspect(s.substring(start=0, end=5), content=\"Hello\")\n///   inspect(s.substring(start=6, end=11), content=\"world\")\n///   inspect(s.substring(), content=\"Hello world\")\n///\n///   let s = \"test\"\n///   inspect(s.substring(start=2, end=2), content=\"\")\n///   inspect(\"\".substring(), content=\"\")\n/// ```\npub fn String::substring(self : String, start? : Int = 0, end? : Int) -> String {\n  let len = self.length()\n  let end = match end {\n    Some(end) => end\n    None => len\n  }\n  guard start >= 0 && start <= end && end <= len\n  unsafe_substring(self, start, end)\n}\n\n///|\ntest \"substring/empty\" {\n  let s = \"test\"\n  inspect(s.substring(start=2, end=2), content=\"\")\n  inspect(s.substring(start=4, end=4), content=\"\")\n  inspect(\"\".substring(), content=\"\")\n}\n\n///|\ntest \"panic substring/invalid_range\" {\n  let s = \"test\"\n  ignore(s.substring(start=-1))\n  ignore(s.substring(end=5))\n  ignore(s.substring(start=3, end=2))\n}\n\n///|\ntest \"substring/basic\" {\n  inspect(\"Hello world\".substring(start=0, end=5), content=\"Hello\")\n  inspect(\"Hello world\".substring(start=6, end=11), content=\"world\")\n  inspect(\"Hello world\".substring(start=0), content=\"Hello world\")\n  inspect(\"Hello world\".substring(start=6), content=\"world\")\n}\n\n///|\ntest \"substring/boundary\" {\n  inspect(\"\".substring(start=0, end=0), content=\"\")\n  inspect(\"a\".substring(start=0, end=1), content=\"a\")\n  inspect(\"abc\".substring(start=0), content=\"abc\")\n  inspect(\"abc\".substring(start=1), content=\"bc\")\n  inspect(\"abc\".substring(start=0, end=3), content=\"abc\")\n}\n\n///|\ntest \"panic substring/out_of_bounds\" {\n  ignore(\"hello\".substring(start=-1, end=4))\n  ignore(\"hello\".substring(start=6, end=4))\n  ignore(\"hello\".substring(start=0, end=6))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with op_equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt\n///   let map = { 3: \"three\", 8 :  \"eight\", 1 :  \"one\"}\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : Array[(K, V)]) -> Map[K, V] {\n  let m = Map::new(capacity=arr.length())\n  arr.each(e => m.set(e.0, e.1))\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map : Map[String, Int] = Map::new()\n///   map.set(\"key\", 42)\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   map.set(\"key\", 24) // update existing key\n///   inspect(map.get(\"key\"), content=\"Some(24)\")\n/// ```\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Sets the value associated with a key in the hash map. If the key already\n/// exists, updates its value; otherwise, adds a new key-value pair. This\n/// function is automatically called when using the index assignment syntax\n/// `map[key] = value`.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to associate with the value. Must implement `Hash` and `Eq`\n/// traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map : Map[String, Int] = Map::new()\n///   map[\"key\"] = 42\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n/// ```\npub fn[K : Hash + Eq, V] Map::op_set(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Unit {\n  self.set(key, value)\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"key\": 42 }\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   inspect(map.get(\"nonexistent\"), content=\"None\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::op_get(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          self.push_away(idx, entry)\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```moonbit\n/// \n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```moonbit\n///   let map = { \"a\": 1, \"b\": 2 }\n///   map.remove(\"a\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.size(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\npub fn[K, V] Map::size(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, value, next, .. }) => {\n      guard yield_((key, value)) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => break IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  Iter2::new(yield_ => loop self.head {\n    Some({ key, value, next, .. }) => {\n      guard yield_(key, value) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  Iter::new(yield_ => loop self.head {\n    Some({ key, next, .. }) => {\n      guard yield_(key) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  Iter::new(yield_ => loop self.head {\n    Some({ value, next, .. }) => {\n      guard yield_(value) is IterContinue else { break IterEnd }\n      continue next\n    }\n    None => IterContinue\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with op_equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let m = Map::new(capacity=length)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  for e in iter {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```moonbit\n/// let map = { \"a\": 1, \"b\": 2 }\n///\n/// // Update existing value\n/// map.update(\"a\", fn(v) { \n///   match v { \n///     Some(x) => Some(x + 10) \n///     None => Some(0) \n///   } \n/// })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"b\": 2}\n/// ))\n///\n/// // Insert new value\n/// map.update(\"c\", fn(v) { \n///   match v { \n///     Some(x) => Some(x) \n///     None => Some(3) \n///   } \n/// })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"b\": 2, \"c\": 3}\n/// ))\n///\n/// // Remove existing value\n/// map.update(\"b\", fn(_) { None })\n/// inspect(map, content=(\n///   #|{\"a\": 11, \"c\": 3}\n/// ))\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```moonbit\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```moonbit\n/// inspect((0xD800).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n/// inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```moonbit\n///   inspect((0xD800).is_surrogate(), content=\"true\")  // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\")  // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\")  // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\")   // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") // 😀 emoji codepoint\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```moonbit skip\n///   println(42)\n///   println(\"Hello, World!\")\n///   println([1, 2, 3])\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```moonbit\n///   let x : Int = 42\n///   inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"a中\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣a\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"a中🤣中\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```moonbit skip\n///   inspect(42, content=\"42\")\n///   inspect(\"hello\", content=\"hello\")\n///   inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content? : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_string().escape()\n    let args_loc = args_loc.to_json().escape()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```moonbit\n///   let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n///   match err {\n///     SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n///   }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"file:line:column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\npub fn SourceLoc::to_string(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => loc.to_string() |> Show::output(buf)\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","///|\n// Pokemon Data Reader - 内存中存储宝可梦信息\n// 直接在代码中定义宝可梦数据，无需文件 I/O\n\n///|\n// ===== 宝可梦数据结构 =====\n\n/// 宝可梦数据集合\npub struct PokemonDatabase {\n  pokemons: Array[Pokemon];\n  last_updated: String\n}\n\n///|\n// ===== 宝可梦数据定义 =====\n\n/// 获取所有宝可梦数据\nfn get_pokemon_data() -> Array[Pokemon] {\n  [\n    Pokemon::{\n      id: 1,\n      name: \"妙蛙种子\",\n      level: 5,\n      hp: 45,\n      max_hp: 45,\n      attack: 49,\n      defense: 49,\n      speed: 45,\n      types: [PokemonType::Grass, PokemonType::Poison],\n      moves: [\"藤鞭\", \"生长\", \"睡眠粉\"]\n    },\n    Pokemon::{\n      id: 2,\n      name: \"小火龙\",\n      level: 5,\n      hp: 39,\n      max_hp: 39,\n      attack: 52,\n      defense: 43,\n      speed: 65,\n      types: [PokemonType::Fire],\n      moves: [\"火花\", \"抓\", \"叫声\"]\n    },\n    Pokemon::{\n      id: 3,\n      name: \"杰尼龟\",\n      level: 5,\n      hp: 44,\n      max_hp: 44,\n      attack: 48,\n      defense: 65,\n      speed: 43,\n      types: [PokemonType::Water],\n      moves: [\"水枪\", \"缩壳\", \"撞击\"]\n    },\n    Pokemon::{\n      id: 4,\n      name: \"皮卡丘\",\n      level: 10,\n      hp: 35,\n      max_hp: 35,\n      attack: 55,\n      defense: 40,\n      speed: 90,\n      types: [PokemonType::Electric],\n      moves: [\"十万伏特\", \"电光一闪\", \"铁尾\"]\n    },\n    Pokemon::{\n      id: 5,\n      name: \"喷火龙\",\n      level: 36,\n      hp: 78,\n      max_hp: 78,\n      attack: 84,\n      defense: 78,\n      speed: 100,\n      types: [PokemonType::Fire, PokemonType::Flying],\n      moves: [\"火焰放射\", \"翅膀攻击\", \"龙爪\"]\n    }\n  ]\n}\n\n/// 创建宝可梦数据库\npub fn create_pokemon_database() -> PokemonDatabase {\n  PokemonDatabase::{\n    pokemons: get_pokemon_data(),\n    last_updated: \"2024-01-01\"\n  }\n}\n\n///|\n// ===== 宝可梦查询功能 =====\n\n/// 根据 ID 查找宝可梦\npub fn find_pokemon_by_id(db: PokemonDatabase, id: Int) -> Option[Pokemon] {\n  let mut result: Option[Pokemon] = None\n  let mut i = 0\n  while i < db.pokemons.length() {\n    let pokemon = db.pokemons[i]\n    if pokemon.id == id {\n      result = Some(pokemon)\n      break\n    }\n    i = i + 1\n  }\n  result\n}\n\n/// 根据名称查找宝可梦\npub fn find_pokemon_by_name(db: PokemonDatabase, name: String) -> Option[Pokemon] {\n  let mut result: Option[Pokemon] = None\n  let mut i = 0\n  while i < db.pokemons.length() {\n    let pokemon = db.pokemons[i]\n    if pokemon.name == name {\n      result = Some(pokemon)\n      break\n    }\n    i = i + 1\n  }\n  result\n}\n\n/// 根据类型查找宝可梦\npub fn find_pokemon_by_type(db: PokemonDatabase, pokemon_type: PokemonType) -> Array[Pokemon] {\n  let mut result: Array[Pokemon] = []\n  let mut i = 0\n  while i < db.pokemons.length() {\n    let pokemon = db.pokemons[i]\n    let mut found = false\n    let mut j = 0\n    while j < pokemon.types.length() {\n      if pokemon.types[j] == pokemon_type {\n        found = true\n        break\n      }\n      j = j + 1\n    }\n    if found {\n      result = result + [pokemon]\n    }\n    i = i + 1\n  }\n  result\n}\n\n/// 获取所有宝可梦\npub fn get_all_pokemons(db: PokemonDatabase) -> Array[Pokemon] {\n  db.pokemons\n}\n\n/// 获取宝可梦数量\npub fn get_pokemon_count(db: PokemonDatabase) -> Int {\n  db.pokemons.length()\n}\n\n///|\n// ===== 显示功能 =====\n\n/// 显示宝可梦信息\npub fn display_pokemon_info(pokemon: Pokemon) -> Unit {\n  println(\"=== \" + pokemon.name + \" ===\")\n  println(\"ID: \" + pokemon.id.to_string())\n  println(\"等级: \" + pokemon.level.to_string())\n  println(\"HP: \" + pokemon.hp.to_string() + \"/\" + pokemon.max_hp.to_string())\n  println(\"攻击: \" + pokemon.attack.to_string())\n  println(\"防御: \" + pokemon.defense.to_string())\n  println(\"速度: \" + pokemon.speed.to_string())\n  println(\"属性1: \" + pokemon.types[0].to_string())\n  match pokemon.types.length() {\n    2 => println(\"属性2: \" + pokemon.types[1].to_string())\n    _ => println(\"属性2: 无\")\n  }\n  println(\"技能: \" + pokemon.moves.join(\", \"))\n  println(\"---\")\n}\n\n/// 显示所有宝可梦信息\npub fn display_all_pokemons(db: PokemonDatabase) -> Unit {\n  println(\"=== 宝可梦数据库 ===\")\n  println(\"最后更新: \" + db.last_updated)\n  println(\"宝可梦数量: \" + db.pokemons.length().to_string())\n  \n  let mut i = 0\n  while i < db.pokemons.length() {\n    display_pokemon_info(db.pokemons[i])\n    i = i + 1\n  }\n}\n\n///|\n// ===== 控制台测试功能 =====\n\n/// 测试并打印所有宝可梦数据\npub fn test_and_print_pokemon_data() -> Unit {\n  println(\" 开始测试宝可梦数据读取...\")\n  println(\"==================================================\")\n  \n  // 创建数据库\n  let db = create_pokemon_database()\n  println(\"✅ 宝可梦数据库创建成功\")\n  println(\"📊 数据库包含 \" + get_pokemon_count(db).to_string() + \" 只宝可梦\")\n  println(\"\")\n  \n  // 显示所有宝可梦\n  display_all_pokemons(db)\n  \n  // 测试查找功能\n  println(\"🔍 测试查找功能:\")\n  println(\"\")\n  \n  // 按ID查找\n  match find_pokemon_by_id(db, 1) {\n    Some(pokemon) => {\n      println(\"✅ 按ID查找成功:\")\n      display_pokemon_info(pokemon)\n    }\n    None => println(\"❌ 按ID查找失败\")\n  }\n  \n  // 按名称查找\n  match find_pokemon_by_name(db, \"皮卡丘\") {\n    Some(pokemon) => {\n      println(\"✅ 按名称查找成功:\")\n      display_pokemon_info(pokemon)\n    }\n    None => println(\"❌ 按名称查找失败\")\n  }\n  \n  // 按类型查找\n  let fire_pokemons = find_pokemon_by_type(db, PokemonType::Fire)\n  println(\"🔥 火系宝可梦 (\" + fire_pokemons.length().to_string() + \" 只):\")\n  let mut i = 0\n  while i < fire_pokemons.length() {\n    let pokemon = fire_pokemons[i]\n    println(\"  - \" + pokemon.name + \" (Lv.\" + pokemon.level.to_string() + \")\")\n    i = i + 1\n  }\n  println(\"\")\n  \n  // 按类型查找草系\n  let grass_pokemons = find_pokemon_by_type(db, PokemonType::Grass)\n  println(\" 草系宝可梦 (\" + grass_pokemons.length().to_string() + \" 只):\")\n  let mut j = 0\n  while j < grass_pokemons.length() {\n    let pokemon = grass_pokemons[j]\n    println(\"  - \" + pokemon.name + \" (Lv.\" + pokemon.level.to_string() + \")\")\n    j = j + 1\n  }\n  println(\"\")\n  \n  println(\"🎉 宝可梦数据测试完成!\")\n  println(\"==================================================\")\n}\n\n///|\n// ===== 测试函数 =====\n\ntest \"test_pokemon_database_operations\" {\n  let db = create_pokemon_database()\n  \n  // 测试查找功能\n  let bulbasaur = find_pokemon_by_id(db, 1)\n  match bulbasaur {\n    Some(p) => {\n      assert_eq!(p.name, \"妙蛙种子\")\n      assert_eq!(p.types[0], PokemonType::Grass)\n    }\n    None => assert_false!(true)\n  }\n  \n  // 测试名称查找\n  let pikachu = find_pokemon_by_name(db, \"皮卡丘\")\n  match pikachu {\n    Some(p) => {\n      assert_eq!(p.id, 4)\n      assert_eq!(p.types[0], PokemonType::Electric)\n    }\n    None => assert_false!(true)\n  }\n  \n  // 测试类型查找\n  let fire_pokemons = find_pokemon_by_type(db, PokemonType::Fire)\n  assert_eq!(fire_pokemons.length(), 2) // 小火龙和喷火龙\n  \n  // 测试数量\n  assert_eq!(get_pokemon_count(db), 5)\n}"],"names":["Result$Err$0$","param0","Result$Ok$0$","Error$moonbitlang$47$core$47$builtin$46$SnapshotError$46$SnapshotError","Error$moonbitlang$47$core$47$builtin$46$InspectError$46$InspectError","Error$moonbitlang$47$core$47$builtin$46$Failure$46$Failure","Result$Err$1$","Result$Ok$1$","KrystalRay$pokemoon$$moonbit_test_driver_internal_get_file_name","Error$$to_string","*e","KrystalRay$pokemoon$$moonbit_test_driver_internal_no_args_tests","moonbitlang$core$abort$$abort$3$","msg","moonbitlang$core$builtin$$Logger$write_object$4$","self","obj","moonbitlang$core$builtin$$Show$output$5$","*x_2478","*x_2479","*Failure","**err_payload_2480","moonbitlang$core$array$$FixedArray$unsafe_blit$6$","dst","dst_offset","src","src_offset","len","_tmp","i","moonbitlang$core$builtin$$UninitializedArray$unsafe_blit$7$","moonbitlang$core$builtin$$StringBuilder$new$46$inner","size_hint","moonbitlang$core$builtin$$StringBuilder$to_string","moonbitlang$core$builtin$$Logger$write_char$8$","ch","*bind","moonbitlang$core$builtin$$op_notequal$4$","x","y","moonbitlang$core$builtin$$op_notequal$9$","moonbitlang$core$string$$String$escape","buf","moonbitlang$core$array$$Array$op_get$4$","index","moonbitlang$core$array$$Array$op_get$9$","moonbitlang$core$array$$Array$op_get$7$","moonbitlang$core$builtin$$Logger$write_string$8$","str","moonbitlang$core$builtin$$Hasher$combine$4$","value","moonbitlang$core$builtin$$Hasher$avalanche","acc","moonbitlang$core$builtin$$Hasher$finalize","moonbitlang$core$builtin$$Hasher$new$46$inner","seed","moonbitlang$core$builtin$$Hash$hash$10$","*self","moonbitlang$core$builtin$$Show$to_string$11$","logger","moonbitlang$core$builtin$$Show$to_string$13$","moonbitlang$core$builtin$$Show$to_string$0$","moonbitlang$core$string$$String$charcode_at","moonbitlang$core$builtin$$output$46$inner$46$abs$124$1877","n","moonbitlang$core$builtin$$output$46$inner$46$write_digits$124$1879","*env","num","radix","num2","moonbitlang$core$int$$Int$output$46$inner","moonbitlang$core$int$$Int$output_size_hint$46$inner","moonbitlang$core$int$$Int$to_string$46$inner","moonbitlang$core$builtin$$Show$to_string$3$","moonbitlang$core$builtin$$debug_string$4$","t","moonbitlang$core$builtin$$debug_string$9$","moonbitlang$core$builtin$$debug_string$3$","moonbitlang$core$builtin$$fail$15$","loc","moonbitlang$core$builtin$$assert_eq$4$","a","b","fail_msg","*Some","moonbitlang$core$builtin$$assert_eq$9$","moonbitlang$core$builtin$$assert_eq$3$","moonbitlang$core$string$$String$substring$46$inner","start","end","moonbitlang$core$builtin$$Logger$write_substring$8$","moonbitlang$core$builtin$$Show$output$12$","moonbitlang$core$builtin$$Show$output$3$","moonbitlang$core$builtin$$to_hex_digit","moonbitlang$core$builtin$$output$46$flush_segment$124$1915","seg","moonbitlang$core$builtin$$Show$output$4$","code","c","moonbitlang$core$builtin$$Show$to_string$4$","moonbitlang$core$option$$Option$unwrap$16$","moonbitlang$core$option$$Option$unwrap$17$","moonbitlang$core$builtin$$calc_grow_threshold","capacity","moonbitlang$core$int$$Int$next_power_of_two","moonbitlang$core$builtin$$Map$new$46$inner$1$","moonbitlang$core$builtin$$Map$new$46$inner$2$","moonbitlang$core$array$$Array$each$18$","f","*len","*i","v","moonbitlang$core$array$$Array$each$19$","moonbitlang$core$builtin$$Map$add_entry_to_tail$1$","idx","entry","moonbitlang$core$builtin$$Map$add_entry_to_tail$2$","moonbitlang$core$builtin$$Map$set_entry$1$","new_idx","*next","moonbitlang$core$builtin$$Map$set_entry$2$","moonbitlang$core$builtin$$Map$push_away$1$","psl","*curr_entry","moonbitlang$core$builtin$$Map$push_away$2$","moonbitlang$core$builtin$$Map$set_with_hash$1$","key","hash","*idx","*psl","moonbitlang$core$builtin$$Map$set_with_hash$2$","moonbitlang$core$builtin$$Map$grow$1$","old_head","new_capacity","*param","*x","*key","*value","*hash","moonbitlang$core$builtin$$Map$grow$2$","moonbitlang$core$builtin$$Map$set$1$","moonbitlang$core$builtin$$Map$set$2$","moonbitlang$core$builtin$$Map$from_array$1$","arr","m","e","moonbitlang$core$builtin$$Map$from_array$2$","moonbitlang$core$builtin$$Map$get$2$","*entry","moonbitlang$core$builtin$$Map$get$1$","moonbitlang$core$builtin$$rotl","r","moonbitlang$core$builtin$$Hasher$consume4","input","moonbitlang$core$builtin$$Hasher$combine_uint","moonbitlang$core$builtin$$Hasher$combine_string","*end883","moonbitlang$core$builtin$$Hash$hash_combine$4$","hasher","moonbitlang$core$builtin$$Hash$hash$3$","moonbitlang$core$builtin$$println$4$","moonbitlang$core$builtin$$Show$output$14$","moonbitlang$core$builtin$$assert_false","moonbitlang$core$builtin$$Add$op_add$20$","other","result","moonbitlang$core$array$$Array$is_empty$4$","moonbitlang$core$builtin$$Show$output$9$","*x_873","*x_874","moonbitlang$core$builtin$$Eq$op_equal$9$","*x_869","*x_870","KrystalRay$pokemoon$$get_pokemon_data","KrystalRay$pokemoon$$create_pokemon_database","KrystalRay$pokemoon$$find_pokemon_by_id","db","id","pokemon","KrystalRay$pokemoon$$find_pokemon_by_name","name","KrystalRay$pokemoon$$find_pokemon_by_type","pokemon_type","found","j","KrystalRay$pokemoon$$get_pokemon_count","KrystalRay$pokemoon$$__test_706f6b656d6f6e5f646174612e6d6274_0","bulbasaur","p","*ok","*p","pikachu","fire_pokemons","KrystalRay$pokemoon$$moonbit_test_driver_internal_execute","filename","file_filter","index_filter","filtered_test","index_func_map","*index_func_map","test_name","message","item","*item","func","attrs","*try_err","*err","*InspectError","*SnapshotError","file_name","KrystalRay$pokemoon$$moonbit_test_driver_finish"],"mappings":"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"}