<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>Moonbit中国象棋战役版 | Moonbit AI游戏</title>
    <meta name="description" content="体验基于中国传统象棋规则的创新战役玩法，采用Moonbit AI核心技术，带来前所未有的游戏体验。">
    <meta name="blog" content="https://spaceack.github.io/">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border-bottom: 2px solid #cda434;
        }

        h1 {
            font-size: 2.5rem;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            letter-spacing: 2px;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #e0e0e0;
            max-width: 800px;
            margin: 0 auto;
        }

        .game-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(40, 30, 20, 0.85);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid #755;
        }

        .left-panel,
        .right-panel {
            width: 300px;
        }

        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .panel h2 {
            color: #ffd700;
            border-bottom: 2px solid #cda434;
            padding-bottom: 10px;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .panel-content {
            line-height: 1.6;
            color: #e0e0e0;
        }

        .panel-content p {
            margin-bottom: 15px;
        }

        canvas {
            display: block;
            background: #e8c78e;
            border: 4px solid #5d4037;
            border-radius: 5px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            cursor: pointer;
        }

        .controls {
            width: 100%;
            background: rgba(40, 30, 20, 0.85);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 200px;
        }

        label {
            color: #ffd700;
            margin-bottom: 5px;
            font-weight: bold;
        }

        select,
        .status-display {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #755;
            background: #2c1f15;
            color: #ffd700;
            font-size: 1rem;
        }

        .status-display {
            background: #1a472a;
            font-weight: bold;
        }

        .game-info {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .info-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            min-width: 120px;
            text-align: center;
        }

        .info-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: #ffd700;
        }

        .instructions {
            background: rgba(40, 30, 20, 0.85);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .instructions h2 {
            color: #ffd700;
            border-bottom: 2px solid #cda434;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .instructions ul {
            padding-left: 20px;
            margin-top: 10px;
        }

        .instructions li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .piece-red {
            background: radial-gradient(circle at 30% 30%, #ff9999, #cc0000);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .piece-black {
            background: radial-gradient(circle at 30% 30%, #666, #000);
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.5);
            color: #ffd700;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 100;
            border: 3px solid #cda434;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
            display: none;
        }

        .win-message h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .win-message p {
            margin-bottom: 20px;
            font-size: 1.2rem;
        }

        .restart-btn {
            background: linear-gradient(to bottom, #ffd700, #b8860b);
            color: #000;
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .restart-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .board-container {
            position: relative;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 50;
            border-radius: 5px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .highlight {
            color: #ff6b6b;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Moonbit中国象棋-战役版</h1>
            <p class="subtitle">穿越楚汉之争，助霸王项羽突破重围，体验中国传统象棋的创新战役玩法</p>
        </header>

        <div class="game-container">
            <div class="panel left-panel">
                <h2>游戏介绍</h2>
                <div class="panel-content">
                    <p>在中国传统象棋的棋盘与棋子规则基础上，我们引入了创新的战役玩法，为这款经典游戏增添了更多乐趣与刺激感。</p>
                    <p>本游戏采用 Moonbit AI核心，凭借其高效的算法，确保了流畅无比与酣畅淋漓的游戏体验，让每一场对弈都充满无限可能。</p>

                    <h3 style="color:#ffd700; margin-top:20px;">战役：垓下之战</h3>
                    <p>在这款游戏中，玩家将穿越时空回到楚汉相争的烽火岁月，置身于那史诗般的战局之中。</p>
                    <p>你将扮演楚霸王项羽身边的谋士"战车"，肩负起协助这位传奇英雄突破刘邦军队重重围堵的重要使命。</p>
                    <p>你的终极目标是运用智慧与策略，消灭敌军，帮助楚霸王“过河”。</p>
                </div>
            </div>

            <div class="center-panel">
                <div class="board-container">
                    <canvas id="chessboard" width="540" height="600"></canvas>
                    <div class="overlay" id="overlay"></div>
                    <div class="win-message" id="winMessage">
                        <h2 id="winTitle">恭喜获胜！</h2>
                        <p id="winText">你坚持了成功协助项羽突破重围，渡河脱险！</p>
                        <button class="restart-btn" onclick="resetGame()">再战一局</button>
                    </div>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label for="player">选择战役：</label>
                        <select id="player">
                            <option value="1">垓下之战</option>
                            <option value="2" disabled>赤壁之战(开发中)</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="difficulty">选择难度：</label>
                        <select id="difficulty">
                            <option value="1">霸王别姬</option>
                            <option value="2" disabled>破釜沉舟(开发中)</option>
                        </select>
                    </div>

                    <div class="game-info">
                        <div class="info-item">
                            <div>回合数</div>
                            <div class="info-value" id="turnCount">0</div>
                        </div>

                        <div class="info-item">
                            <div>游戏状态</div>
                            <div class="info-value status-display" id="gameStatus">游戏中</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel right-panel">
                <h2>玩法说明</h2>
                <div class="panel-content">
                    <ul>
                        <li><span class="highlight">操作方式：</span>使用鼠标点击并拖动棋子</li>
                        <li><span class="highlight">游戏目标：</span>消灭敌军，坚持<del>300</del> 5回合（测试版降低难度）</li>
                        <li><span class="highlight">棋子规则：</span>敌军兵棋可上下左右自由移动</li>
                    </ul>

                    <h3 style="color:#ffd700; margin-top:20px;">策略提示</h3>
                    <p>黑兵会试图包围你的红车，尽量消灭敌军，坚持更多的回合。</p>
                    <p>注意：黑兵每3回合会增援一次，合理规划你的移动路线！</p>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h2>历史背景：垓下之战</h2>
            <div class="panel-content">
                <p>垓下之战（公元前202年）是楚汉战争的最后一场大战，汉高祖刘邦联合韩信、彭越等各路诸侯，合围楚军于垓下（今安徽省灵璧县境内）。</p>
                <p>项羽率十万楚军在此与六十万汉军展开决战，最终楚军大败，项羽突围至乌江自刎而死。此战确立了汉王朝400多年的基业，也留下了"四面楚歌"、"霸王别姬"等著名典故。</p>
                <p>在本游戏中，你扮演项羽的谋士，帮助项羽成功突围渡河，逃离汉军的包围。</p>
            </div>
        </div>
    </div>

    <footer>
        <p>Moonbit中国象棋-战役版 | 基于中国传统象棋的创新战役玩法</p>
    </footer>

    <script>
        let wasmInstance;
        async function loadWasm() {
            try {
                const wasmModule = await WebAssembly.instantiateStreaming(
                    fetch('game.wasm')
                );
                wasmInstance = wasmModule.instance;
                console.log('WASM 加载成功');
            } catch (error) {
                console.error('WASM 加载失败:', error);
                document.getElementById('result').innerHTML = 'WASM 加载失败: ' + error.message;
            }
        }

        window.onload = function () {
            loadWasm();
            initGame();
        };
        const canvas = document.getElementById('chessboard');
        const ctx = canvas.getContext('2d');
        let turnCount = 0;
        let gameStatus = "游戏中";
        const cols = 9;
        const rows = 10;
        const gridSize = 60;
        const pieceRadius = 22;
        const boardOffsetX = (canvas.width - gridSize * (cols - 1)) / 2;
        const boardOffsetY = (canvas.height - gridSize * (rows - 1)) / 2;

        let dragging = false;
        let dragPiece = null;
        let dragFrom = null;
        const boardState = {};

        function initGame() {
            for (let key in boardState) {
                delete boardState[key];
            }
            boardState['4,5'] = { type: '车', color: 'red', draggable: true };
            boardState['4,2'] = { type: '兵', color: 'black', draggable: false };
            boardState['2,2'] = { type: '兵', color: 'black', draggable: false };
            boardState['6,2'] = { type: '兵', color: 'black', draggable: false };
            turnCount = 0;
            gameStatus = "游戏中";
            updateGameInfo();
            drawBoard();
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#e8c78e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            ctx.fillRect(boardOffsetX, boardOffsetY + 4 * gridSize,
                gridSize * 8, gridSize);

            ctx.font = '24px serif';
            ctx.fillStyle = '#1a5ca3';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('楚        河                          汉      界', canvas.width / 2, boardOffsetY + 4.5 * gridSize);

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;

            for (let i = 0; i < rows; i++) {
                ctx.beginPath();
                ctx.moveTo(boardOffsetX, boardOffsetY + i * gridSize);
                ctx.lineTo(boardOffsetX + (cols - 1) * gridSize, boardOffsetY + i * gridSize);
                ctx.stroke();
            }

            for (let j = 0; j < cols; j++) {
                ctx.beginPath();
                ctx.moveTo(boardOffsetX + j * gridSize, boardOffsetY);
                ctx.lineTo(boardOffsetX + j * gridSize, boardOffsetY + 4 * gridSize);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(boardOffsetX + j * gridSize, boardOffsetY + 5 * gridSize);
                ctx.lineTo(boardOffsetX + j * gridSize, boardOffsetY + 9 * gridSize);
                ctx.stroke();
            }

            for (let key in boardState) {
                const [x, y] = key.split(',').map(Number);
                drawPiece(x, y, boardState[key]);
            }
        }

        function drawPiece(x, y, piece) {
            const px = boardOffsetX + x * gridSize;
            const py = boardOffsetY + y * gridSize;

            ctx.beginPath();
            ctx.arc(px, py, pieceRadius, 0, Math.PI * 2);

            if (piece.color === 'red') {
                ctx.fillStyle = '#cc0000';
            } else {
                ctx.fillStyle = '#000';
            }

            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.fillStyle = piece.color === 'red' ? '#fff' : '#fff';
            ctx.font = 'bold 24px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(piece.type, px, py);

            if (piece === dragPiece) {
                ctx.beginPath();
                ctx.arc(px, py, pieceRadius + 3, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function updateGameInfo() {
            document.getElementById('turnCount').textContent = turnCount;
            document.getElementById('gameStatus').textContent = gameStatus;
        }

        function showWinMessage(isWin) {
            const winMessage = document.getElementById('winMessage');
            const winTitle = document.getElementById('winTitle');
            const winText = document.getElementById('winText');
            const overlay = document.getElementById('overlay');

            if (isWin) {
                winTitle.textContent = "恭喜获胜！";
                winText.textContent = "你成功协助项羽突破重围，渡河脱险！";
                winTitle.style.color = "#ffd700";
            } else {
                winTitle.textContent = "游戏结束";
                winText.textContent = "项羽未能突破重围，霸王别姬！";
                winTitle.style.color = "#ff6b6b";
            }

            winMessage.style.display = "block";
            overlay.style.display = "block";
        }

        function resetGame() {
            const winMessage = document.getElementById('winMessage');
            const overlay = document.getElementById('overlay');

            winMessage.style.display = "none";
            overlay.style.display = "none";

            initGame();
            window.location.reload();
        }

        canvas.addEventListener('mousedown', (e) => {
            if (gameStatus !== "游戏中") return;

            const [x, y] = getBoardCoords(e.offsetX, e.offsetY);
            const key = `${x},${y}`;
            const piece = boardState[key];

            if (piece && piece.color === 'red' && piece.draggable) {
                dragging = true;
                dragPiece = piece;
                dragFrom = { x, y };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (dragging && dragPiece) {
                drawBoard();
                drawPieceAtPixel(e.offsetX, e.offsetY, dragPiece);
            }
        });
        canvas.addEventListener('mouseup', (e) => {
            if (!dragging) return;
            dragging = false;

            const [toX, toY] = getBoardCoords(e.offsetX, e.offsetY);
            const fromX = dragFrom.x;
            const fromY = dragFrom.y;
            const fromKey = `${fromX},${fromY}`;
            const toKey = `${toX},${toY}`;

            if (toX === fromX && toY === fromY) {
                drawBoard();
                dragPiece = null;
                return;
            }

            try {
                let step = encodePosition(toX, toY);
                const result = wasmInstance.exports.echoname(step);
                const isWinFlag = (result >>> 31) & 1;
                const canMove = (result >>> 30) & 1;

                if (canMove === 1) {
                    const movingPiece = boardState[fromKey];
                    delete boardState[fromKey];
                    boardState[toKey] = movingPiece;

                    turnCount++;

                    if (isWinFlag === 1) {
                        gameStatus = "胜利";
                        showWinMessage(true);
                        updateGameInfo();
                        drawBoard();
                        return;
                    }
                    if (isMiddleBitsZero(result)) {
                        const { srcIndex, dstIndex } = moveChessDecode(result);
                        if (srcIndex < 90 && dstIndex < 90) {
                            const src = decodePosIndex(srcIndex);
                            const dst = decodePosIndex(dstIndex);
                            const srcKey = `${src.x},${src.y}`;
                            const dstKey = `${dst.x},${dst.y}`;
                            const aiMovingPiece = boardState[srcKey];
                            if (aiMovingPiece) {
                                delete boardState[srcKey];
                                boardState[dstKey] = aiMovingPiece;
                            }
                        }
                    }
                    if (turnCount % 3 === 0) {
                        const { srcIndex, dstIndex } = moveChessDecode(result);
                        let pieceData = result & ((1 << 30) - 1);
                        for (let i = 0; i < 3; i++) {
                            let pieceCode = pieceData & 0x3FF;
                            let pos = (pieceCode >>> 3) & 0x7F;
                            pieceData >>>= 10;
                            let col = pos % 9;
                            let row = Math.floor(pos / 9);
                            if (pos >= 0 && pos <= 89) {
                                boardState[`${col},${row}`] = { type: '兵', color: 'black', draggable: false };
                            }
                        }
                    } 

                    let redPieceExists = Object.values(boardState).some(p => p.color === 'red');
                    if (!redPieceExists) {
                        gameStatus = "失败";
                        showWinMessage(false);
                    }
                } else {
                    console.log("无效移动");
                }
            } catch (error) {
                console.error('调用失败:', error);
            }

            drawBoard();
            updateGameInfo();
            dragPiece = null;
            dragFrom = null;
        });
        function drawPieceAtPixel(px, py, piece) {
            ctx.beginPath();
            ctx.arc(px, py, pieceRadius, 0, Math.PI * 2);

            if (piece.color === 'red') {
                ctx.fillStyle = '#cc0000';
            } else {
                ctx.fillStyle = '#000';
            }
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = piece.color === 'red' ? '#fff' : '#fff';
            ctx.font = 'bold 24px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(piece.type, px, py);
        }
        function getBoardCoords(px, py) {
            const x = Math.round((px - boardOffsetX) / gridSize);
            const y = Math.round((py - boardOffsetY) / gridSize);
            const clampedX = Math.max(0, Math.min(cols - 1, x));
            const clampedY = Math.max(0, Math.min(rows - 1, y));
            return [clampedX, clampedY];
        }
        function encodePosition(x, y) {
            return y * 9 + x;
        }
        function decodePosIndex(index) {
            const x = index % 9;
            const y = Math.floor(index / 9);
            return { x, y };
        }
        function moveChessDecode(code) {
            const dstIndex = (code >>> 6) & 0x3F;
            const srcIndex = code & 0x3F;
            return { srcIndex, dstIndex };
        }
        function isMiddleBitsZero(value) {
            value >>>= 0;
            const mask = 0x3FFFF000; // 二进制: 111...11000000 (24个1，低6位0)
            const middleBits = value & mask;
            return middleBits === 0;
        }
    </script>
</body>

</html>